diff -uNrp NetCDF95/CMakeLists.txt NetCDF95-mods/CMakeLists.txt
--- NetCDF95/CMakeLists.txt	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/CMakeLists.txt	2020-12-13 01:39:43.985691733 -0600
@@ -1,45 +1,75 @@
-cmake_minimum_required(VERSION 3.13)
-project(NetCDF95 Fortran)
-set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR})
-
-file(STRINGS file_list file_list_var)
-add_library(netcdf95 ${file_list_var})
-
-set_target_properties(netcdf95 PROPERTIES Fortran_MODULE_DIRECTORY
-  ${PROJECT_BINARY_DIR}/modules)
-
-target_include_directories(netcdf95 PUBLIC
-  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}/modules>)
-
-if(CMAKE_Fortran_COMPILER_ID MATCHES NAG)
-  target_include_directories(netcdf95 PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
+###########################################################################
+### CMake Build System for the Parametric Hurricane Model (PaHM)
+### CMakeLists.txt :: The top level CMake configuration file for NetCDF95
+###
+### Author: Panagiotis Velissariou <panagiotis.velissariou@noaa.gov>
+###########################################################################
+
+##################################################
+### GENERAL OPTIONS
+##################################################
+cmake_minimum_required(VERSION 3.0.2)
+#cmake_minimum_required(VERSION 3.13)
+
+###========================================
+### Add our local modules to the module path
+###========================================
+file(REAL_PATH ../../cmake           _d1)
+file(REAL_PATH ../../cmake/Platforms _d2)
+file(REAL_PATH ../../cmake/Modules   _d3)
+list(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake
+                              ${CMAKE_SOURCE_DIR}/cmake/Platforms
+                              ${CMAKE_SOURCE_DIR}/cmake/Modules
+			      ${_d1} ${_d2} ${_d3}
+                              ${CMAKE_CURRENT_SOURCE_DIR}/cmake
+                              ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules)
+list(REMOVE_DUPLICATES CMAKE_MODULE_PATH)
+unset(_d1)
+unset(_d2)
+unset(_d3)
+###========================================
+
+
+project(NetCDF95
+        LANGUAGES Fortran)
+
+
+##################################################
+### BUILD ENVIRONMENT
+##################################################
+
+### This is a required library.
+include(check_netcdf)
+
+### library to archive (libnetcdf.a)
+set(_target_var netcdf95)
+
+file(STRINGS file_list ${_target_var}_SOURCES)
+add_library(${_target_var} STATIC ${${_target_var}_SOURCES})
+
+set(_target_mod_dir "${CMAKE_Fortran_MODULE_DIRECTORY}")
+if("${_target_mod_dir}" STREQUAL "")
+  set(_target_mod_dir ${CMAKE_BINARY_DIR}/CMakeFiles/mod/${_target_var})
 endif()
+target_include_directories(${_target_var} INTERFACE ${_target_mod_dir})
 
-find_path(netcdff_INCLUDE_DIR netcdf.mod)
-find_library(netcdff_LIBRARY netcdff)
-find_package(NetCDF REQUIRED)
-target_include_directories(netcdf95 PRIVATE ${netcdff_INCLUDE_DIR})
-target_link_libraries(netcdf95 PUBLIC ${netcdff_LIBRARY} NetCDF::NetCDF)
-
-include(ConfigureCompilerFlags)
-
-include(CMakePackageConfigHelpers)
-configure_package_config_file(Config.cmake.in
-    ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake
-    INSTALL_DESTINATION lib/cmake/${PROJECT_NAME})
-
-if(CMAKE_Fortran_COMPILER_ID MATCHES NAG|Intel)
-  set(install_include_dir include/${PROJECT_NAME})
-  install(DIRECTORY ${PROJECT_BINARY_DIR}/modules/ DESTINATION
-    ${install_include_dir})
-else()
-  set(install_include_dir include)
-  install(FILES ${PROJECT_BINARY_DIR}/modules/netcdf95.mod TYPE INCLUDE)
-endif()
+target_include_directories(${_target_var} PRIVATE ${NETCDF_INCLUDE_DIRS})
+
+target_link_libraries(${_target_var} PRIVATE ${NETCDF_LIBRARIES})
+    
+set_target_properties(${_target_var} PROPERTIES
+                                     Fortran_MODULE_DIRECTORY ${_target_mod_dir}
+                                     ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}
+                                     LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
+
+install(TARGETS ${_target_var} RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+                               ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+                               LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})
+
+install(DIRECTORY "${_target_mod_dir}/"
+        DESTINATION "include"
+        FILES_MATCHING
+        PATTERN "*.mod")
 
-install(TARGETS netcdf95 EXPORT ${PROJECT_NAME}Targets LIBRARY
-  INCLUDES DESTINATION ${install_include_dir})
-install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake
-  DESTINATION lib/cmake/${PROJECT_NAME})
-install(EXPORT ${PROJECT_NAME}Targets DESTINATION lib/cmake/${PROJECT_NAME})
-export(EXPORT ${PROJECT_NAME}Targets)
+unset(_target_var)
+unset(_target_mod_dir)
diff -uNrp NetCDF95/CMakeLists.txt-orig NetCDF95-mods/CMakeLists.txt-orig
--- NetCDF95/CMakeLists.txt-orig	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/CMakeLists.txt-orig	2020-12-12 23:33:03.260712009 -0600
@@ -0,0 +1,49 @@
+cmake_minimum_required(VERSION 3.13)
+project(NetCDF95 Fortran)
+set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR})
+
+file(STRINGS file_list file_list_var)
+add_library(netcdf95 ${file_list_var})
+
+set_target_properties(netcdf95 PROPERTIES Fortran_MODULE_DIRECTORY
+  ${PROJECT_BINARY_DIR}/modules)
+
+target_include_directories(netcdf95 PUBLIC
+  $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}/modules>)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES NAG)
+  target_include_directories(netcdf95 PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
+endif()
+
+find_package(NetCDF REQUIRED)
+include(FindPkgConfig)
+pkg_check_modules(netcdf-fortran REQUIRED IMPORTED_TARGET netcdf-fortran)
+
+target_link_libraries(netcdf95 PUBLIC PkgConfig::netcdf-fortran
+  PRIVATE NetCDF::NetCDF)
+
+target_include_directories(netcdf95 PUBLIC ${netcdf-fortran_INCLUDEDIR})
+  
+include(ConfigureCompilerFlags)
+add_subdirectory(Test)
+
+include(CMakePackageConfigHelpers)
+configure_package_config_file(Config.cmake.in
+    ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake
+    INSTALL_DESTINATION lib/cmake/${PROJECT_NAME})
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES NAG|Intel)
+  set(install_include_dir include/${PROJECT_NAME})
+  install(DIRECTORY ${PROJECT_BINARY_DIR}/modules/ DESTINATION
+    ${install_include_dir})
+else()
+  set(install_include_dir include)
+  install(FILES ${PROJECT_BINARY_DIR}/modules/netcdf95.mod TYPE INCLUDE)
+endif()
+
+install(TARGETS netcdf95 EXPORT ${PROJECT_NAME}Targets LIBRARY
+  INCLUDES DESTINATION ${install_include_dir})
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake
+  DESTINATION lib/cmake/${PROJECT_NAME})
+install(EXPORT ${PROJECT_NAME}Targets DESTINATION lib/cmake/${PROJECT_NAME})
+export(EXPORT ${PROJECT_NAME}Targets)
diff -uNrp NetCDF95/ConfigureCompilerFlags.cmake NetCDF95-mods/ConfigureCompilerFlags.cmake
--- NetCDF95/ConfigureCompilerFlags.cmake	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/ConfigureCompilerFlags.cmake	1969-12-31 18:00:00.000000000 -0600
@@ -1,68 +0,0 @@
-if(CMAKE_Fortran_COMPILER_ID MATCHES GNU)
-  # Options for a Fortran 2003 program, compiler version 7
-  
-  # Fortran language options:
-  string(APPEND CMAKE_Fortran_FLAGS " -std=f2003")
-
-  # Error and warning options:
-  string(APPEND CMAKE_Fortran_FLAGS
-    " -fmax-errors=1 -pedantic -Wall -Wcharacter-truncation -Wunused-parameter"
-    " -Wno-conversion -Wimplicit-interface -Wimplicit-procedure"
-    " -Wno-integer-division")
-  ## -Wrealloc-lhs-all
-  
-  # Debugging options:
-  set(CMAKE_Fortran_FLAGS_DEBUG
-    "-fbacktrace -g -ffpe-trap=invalid,zero,overflow")
-
-  # Code generation options:
-  string(APPEND CMAKE_Fortran_FLAGS_DEBUG
-    " -fcheck=bounds,do,mem,pointer,recursion -finit-derived -finit-real=snan "
-    "-O0")
-
-  # Optimization options:
-  set(CMAKE_Fortran_FLAGS_RELEASE -O3)
-
-  # Hardware model options:
-  string(APPEND CMAKE_Fortran_FLAGS_RELEASE " -mcmodel=medium")
-elseif(CMAKE_Fortran_COMPILER_ID MATCHES Intel)
-  # Language:
-
-  string(APPEND CMAKE_Fortran_FLAGS
-    " -noaltparam -stand f03 -standard-semantics -assume nostd_mod_proc_name")
-  # -standard-semantics by itself implies -assume std_mod_proc_name, and
-  # then compiling with the NetCDF Fortran library or the FortranGIS
-  # library might not work.
-  
-  string(APPEND CMAKE_Fortran_FLAGS_DEBUG
-    " -check bounds,format,output_conversion,pointers,stack,uninit")
-  # "-check all" includes "arg_temp_created", which is annoying so we
-  # detail "check bounds", etc.
-
-  # Data:
-  string(APPEND CMAKE_Fortran_FLAGS " -auto -mcmodel=medium")
-  string(APPEND CMAKE_Fortran_FLAGS_DEBUG " -init=arrays,minus_huge,snan")
-  
-  # Compiler diagnostics:
-  string(APPEND CMAKE_Fortran_FLAGS
-    " -warn declarations,general,stderrors,truncated_source,uncalled,unused,usage"
-    " -traceback -diag-error-limit 1")
-  # -traceback has no impact on run-time execution speeds.
-  
-  # Optimization:
-  string(APPEND CMAKE_Fortran_FLAGS_DEBUG " -O0")
-  
-  # Floating point:
-  string(APPEND CMAKE_Fortran_FLAGS_DEBUG " -fp-stack-check -fpe-all=0")
-  
-  # Debug:
-  string(APPEND CMAKE_Fortran_FLAGS_DEBUG
-    " -debug full -debug-parameters all -ftrapuv")
-elseif(CMAKE_Fortran_COMPILER_ID MATCHES NAG)
-  string(APPEND CMAKE_Fortran_FLAGS " -f2003")
-
-  string(APPEND CMAKE_Fortran_FLAGS_DEBUG " -C=all -g90 -gline -nan -strict95")
-  #  -C=undefined is not binary compatible with Fortran code compiled
-  #  without that option, and is not compatible with calling C code
-  #  via a BIND(C) interface.
-endif()
diff -uNrp NetCDF95/FindNetCDF.cmake NetCDF95-mods/FindNetCDF.cmake
--- NetCDF95/FindNetCDF.cmake	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/FindNetCDF.cmake	1969-12-31 18:00:00.000000000 -0600
@@ -1,41 +0,0 @@
-find_path(NetCDF_INCLUDE_DIR
-  NAMES netcdf.h
-  DOC "netcdf include directories")
-##mark_as_advanced(NetCDF_INCLUDE_DIR)
-
-find_library(NetCDF_LIBRARY
-  NAMES netcdf
-  DOC "netcdf library")
-##mark_as_advanced(NetCDF_LIBRARY)
-
-if (NetCDF_INCLUDE_DIR)
-  file(STRINGS "${NetCDF_INCLUDE_DIR}/netcdf_meta.h" _netcdf_version_lines
-    REGEX "#define[ \t]+NC_VERSION_(MAJOR|MINOR|PATCH|NOTE)")
-  string(REGEX REPLACE ".*NC_VERSION_MAJOR *\([0-9]*\).*" "\\1" _netcdf_version_major "${_netcdf_version_lines}")
-  string(REGEX REPLACE ".*NC_VERSION_MINOR *\([0-9]*\).*" "\\1" _netcdf_version_minor "${_netcdf_version_lines}")
-  string(REGEX REPLACE ".*NC_VERSION_PATCH *\([0-9]*\).*" "\\1" _netcdf_version_patch "${_netcdf_version_lines}")
-  string(REGEX REPLACE ".*NC_VERSION_NOTE *\"\([^\"]*\)\".*" "\\1" _netcdf_version_note "${_netcdf_version_lines}")
-  set(NetCDF_VERSION "${_netcdf_version_major}.${_netcdf_version_minor}.${_netcdf_version_patch}${_netcdf_version_note}")
-  unset(_netcdf_version_major)
-  unset(_netcdf_version_minor)
-  unset(_netcdf_version_patch)
-  unset(_netcdf_version_note)
-  unset(_netcdf_version_lines)
-endif ()
-
-include(FindPackageHandleStandardArgs)
-find_package_handle_standard_args(NetCDF
-  REQUIRED_VARS NetCDF_LIBRARY NetCDF_INCLUDE_DIR
-  VERSION_VAR NetCDF_VERSION)
-
-if (NetCDF_FOUND)
-  set(NetCDF_INCLUDE_DIRS "${NetCDF_INCLUDE_DIR}")
-  set(NetCDF_LIBRARIES "${NetCDF_LIBRARY}")
-
-  if (NOT TARGET NetCDF::NetCDF)
-    add_library(NetCDF::NetCDF UNKNOWN IMPORTED)
-    set_target_properties(NetCDF::NetCDF PROPERTIES
-      IMPORTED_LOCATION "${NetCDF_LIBRARY}"
-      INTERFACE_INCLUDE_DIRECTORIES "${NetCDF_INCLUDE_DIR}")
-  endif ()
-endif ()
diff -uNrp NetCDF95/README.md NetCDF95-mods/README.md
--- NetCDF95/README.md	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/README.md	2020-12-12 23:33:03.260712009 -0600
@@ -1 +1 @@
-See [NetCDF95 homepage](http://www.lmd.jussieu.fr/~lguez/netcdf95.html).
+See [NetCDF95 homepage](http://www.lmd.jussieu.fr/~lguez/NetCDF95_site).
diff -uNrp NetCDF95/Test/CMakeLists.txt NetCDF95-mods/Test/CMakeLists.txt
--- NetCDF95/Test/CMakeLists.txt	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/Test/CMakeLists.txt	2020-12-12 23:33:03.260712009 -0600
@@ -0,0 +1,2 @@
+add_executable(test_netcdf95 test_netcdf95.f90)
+target_link_libraries(test_netcdf95 PRIVATE netcdf95)
diff -uNrp NetCDF95/Test/test_netcdf95.f NetCDF95-mods/Test/test_netcdf95.f
--- NetCDF95/Test/test_netcdf95.f	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/Test/test_netcdf95.f	1969-12-31 18:00:00.000000000 -0600
@@ -1,18 +0,0 @@
-program test_netcdf95
-
-  ! This is a program in Fortran 95.
-
-  use netcdf, only: nf90_inq_libvers, nf90_nowrite
-  use netcdf95, only: nf95_open, nf95_close
-
-  IMPLICIT none
-
-  integer ncid
-
-  !-----------------------------------------------------------------------
-
-  print *, "NetCDF library version: ", trim(nf90_inq_libvers())
-  call nf95_open("plouf.nc", nf90_nowrite, ncid)
-  call nf95_close(ncid)
-
-END program test_netcdf95
diff -uNrp NetCDF95/Test/test_netcdf95.f90 NetCDF95-mods/Test/test_netcdf95.f90
--- NetCDF95/Test/test_netcdf95.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/Test/test_netcdf95.f90	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,18 @@
+program test_netcdf95
+
+  ! This is a program in Fortran 95.
+
+  use netcdf, only: nf90_inq_libvers, nf90_nowrite
+  use netcdf95, only: nf95_open, nf95_close
+
+  IMPLICIT none
+
+  integer ncid
+
+  !-----------------------------------------------------------------------
+
+  print *, "NetCDF library version: ", trim(nf90_inq_libvers())
+  call nf95_open("plouf.nc", nf90_nowrite, ncid)
+  call nf95_close(ncid)
+
+END program test_netcdf95
diff -uNrp NetCDF95/check_start_count.f90 NetCDF95-mods/check_start_count.f90
--- NetCDF95/check_start_count.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/check_start_count.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,81 +0,0 @@
-module check_start_count_m
-
-  implicit none
-
-  private check_one_arg
-
-contains
-
-  subroutine check_start_count(name_calling, ncid, varid, start, count_nc, &
-       rank_values)
-
-    ! This procedure checks that:
-
-    ! - the size of start and count_nc equals the rank of the NetCDF variable;
-
-    ! - if count_nc is absent, the rank of values is lower than or
-    ! equal to the rank of the NetCDF variable.
-
-    use nf95_close_m, only: nf95_close
-    use nf95_inquire_variable_m, only: nf95_inquire_variable
-    use netcdf, only: nf90_noerr
-
-    character(len=*), intent(in):: name_calling ! name of calling procedure
-    integer, intent(in):: ncid, varid
-    integer, optional, intent(in):: start(:), count_nc(:)
-    integer, intent(in):: rank_values ! rank of argument "values"
-
-    ! Variables local to the procedure:
-    integer ncerr_not_opt, ndims
-
-    !-------------------
-
-    call nf95_inquire_variable(ncid, varid, ndims=ndims, ncerr=ncerr_not_opt)
-    if (ncerr_not_opt == nf90_noerr) then
-       call check_one_arg(name_calling, "start", ncid, varid, ndims, start)
-       call check_one_arg(name_calling, "count_nc", ncid, varid, ndims, &
-            count_nc)
-       if (.not. present(count_nc) .and. rank_values > ndims) then
-          print *, name_calling, ":"
-          print *, "varid = ", varid
-          print *, "Argument count_nc is absent and rank of argument values " &
-               // "is greater than rank of NetCDF variable"
-          print *, "rank of argument values: ", rank_values
-          print *, "rank of NetCDF variable: ", ndims
-          call nf95_close(ncid)
-          stop 1
-       end if
-    end if
-
-  end subroutine check_start_count
-
-  !**************************************************************
-
-  subroutine check_one_arg(name_calling, arg_name, ncid, varid, ndims, &
-       checked_arg)
-
-    use nf95_close_m, only: nf95_close
-
-    character(len=*), intent(in):: name_calling ! name of calling procedure
-    character(len=*), intent(in):: arg_name ! name of checked argument
-    integer, intent(in):: ncid, varid, ndims
-    integer, optional, intent(in):: checked_arg(:) ! start or count_nc
-
-    !-------------------
-
-    if (present(checked_arg)) then
-       if (size(checked_arg) /= ndims) then
-          print *, name_calling, ":"
-          print *, "varid = ", varid
-          print *, 'size of ' // arg_name // ' does not match rank of ' &
-               // 'NetCDF variable'
-          print *, 'size of ' // arg_name // " = ", size(checked_arg)
-          print *, "rank of NetCDF variable: ", ndims
-          call nf95_close(ncid)
-          stop 1
-       end if
-    end if
-
-  end subroutine check_one_arg
-
-end module check_start_count_m
diff -uNrp NetCDF95/cmake/Modules/ConfigureCompilerFlags.cmake NetCDF95-mods/cmake/Modules/ConfigureCompilerFlags.cmake
--- NetCDF95/cmake/Modules/ConfigureCompilerFlags.cmake	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/cmake/Modules/ConfigureCompilerFlags.cmake	2020-12-12 23:33:03.260712009 -0600
@@ -0,0 +1,68 @@
+if(CMAKE_Fortran_COMPILER_ID MATCHES GNU)
+  # Options for a Fortran 2003 program, compiler version 7
+  
+  # Fortran language options:
+  string(APPEND CMAKE_Fortran_FLAGS " -std=f2003")
+
+  # Error and warning options:
+  string(APPEND CMAKE_Fortran_FLAGS
+    " -fmax-errors=1 -pedantic -Wall -Wcharacter-truncation -Wunused-parameter"
+    " -Wno-conversion -Wimplicit-interface -Wimplicit-procedure"
+    " -Wno-integer-division")
+  ## -Wrealloc-lhs-all
+  
+  # Debugging options:
+  set(CMAKE_Fortran_FLAGS_DEBUG
+    "-fbacktrace -g -ffpe-trap=invalid,zero,overflow")
+
+  # Code generation options:
+  string(APPEND CMAKE_Fortran_FLAGS_DEBUG
+    " -fcheck=bounds,do,mem,pointer,recursion -finit-derived -finit-real=snan "
+    "-O0")
+
+  # Optimization options:
+  set(CMAKE_Fortran_FLAGS_RELEASE -O3)
+
+  # Hardware model options:
+  string(APPEND CMAKE_Fortran_FLAGS_RELEASE " -mcmodel=medium")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES Intel)
+  # Language:
+
+  string(APPEND CMAKE_Fortran_FLAGS
+    " -noaltparam -stand f03 -standard-semantics -assume nostd_mod_proc_name")
+  # -standard-semantics by itself implies -assume std_mod_proc_name, and
+  # then compiling with the NetCDF Fortran library or the FortranGIS
+  # library might not work.
+  
+  string(APPEND CMAKE_Fortran_FLAGS_DEBUG
+    " -check bounds,format,output_conversion,pointers,stack,uninit")
+  # "-check all" includes "arg_temp_created", which is annoying so we
+  # detail "check bounds", etc.
+
+  # Data:
+  string(APPEND CMAKE_Fortran_FLAGS " -auto -mcmodel=medium")
+  string(APPEND CMAKE_Fortran_FLAGS_DEBUG " -init=arrays,minus_huge,snan")
+  
+  # Compiler diagnostics:
+  string(APPEND CMAKE_Fortran_FLAGS
+    " -warn declarations,general,stderrors,truncated_source,uncalled,unused,usage"
+    " -traceback -diag-error-limit 1")
+  # -traceback has no impact on run-time execution speeds.
+  
+  # Optimization:
+  string(APPEND CMAKE_Fortran_FLAGS_DEBUG " -O0")
+  
+  # Floating point:
+  string(APPEND CMAKE_Fortran_FLAGS_DEBUG " -fp-stack-check -fpe-all=0")
+  
+  # Debug:
+  string(APPEND CMAKE_Fortran_FLAGS_DEBUG
+    " -debug full -debug-parameters all -ftrapuv")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES NAG)
+  string(APPEND CMAKE_Fortran_FLAGS " -f2003")
+
+  string(APPEND CMAKE_Fortran_FLAGS_DEBUG " -C=all -g90 -gline -nan -strict95")
+  #  -C=undefined is not binary compatible with Fortran code compiled
+  #  without that option, and is not compatible with calling C code
+  #  via a BIND(C) interface.
+endif()
diff -uNrp NetCDF95/cmake/Modules/FindNetCDF.cmake NetCDF95-mods/cmake/Modules/FindNetCDF.cmake
--- NetCDF95/cmake/Modules/FindNetCDF.cmake	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/cmake/Modules/FindNetCDF.cmake	2020-12-12 00:05:11.863372336 -0600
@@ -0,0 +1,355 @@
+# (C) Copyright 2011- ECMWF.
+#
+# This software is licensed under the terms of the Apache Licence Version 2.0
+# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
+# In applying this licence, ECMWF does not waive the privileges and immunities
+# granted to it by virtue of its status as an intergovernmental organisation nor
+# does it submit to any jurisdiction.
+
+# Try to find NetCDF includes and library.
+# Supports static and shared libaries and allows each component to be found in sepearte prefixes.
+#
+# This module defines
+#
+#   - NetCDF_FOUND                - System has NetCDF
+#   - NetCDF_INCLUDE_DIRS         - the NetCDF include directories
+#   - NetCDF_VERSION              - the version of NetCDF
+#   - NetCDF_CONFIG_EXECUTABLE    - the netcdf-config executable if found
+#   - NetCDF_PARALLEL             - Boolean True if NetCDF4 has parallel IO support via hdf5 and/or pnetcdf
+#   - NetCDF_HAS_PNETCDF          - Boolean True if NetCDF4 has pnetcdf support
+#
+# Deprecated Defines
+#   - NetCDF_LIBRARIES            - [Deprecated] Use NetCDF::NetCDF_<LANG> targets instead.
+#
+#
+# Following components are available:
+#
+#   - C                           - C interface to NetCDF          (netcdf)
+#   - CXX                         - CXX4 interface to NetCDF       (netcdf_c++4)
+#   - Fortran                     - Fortran interface to NetCDF    (netcdff)
+#
+# For each component the following are defined:
+#
+#   - NetCDF_<comp>_FOUND         - whether the component is found
+#   - NetCDF_<comp>_LIBRARIES     - the libraries for the component
+#   - NetCDF_<comp>_LIBRARY_SHARED - Boolean is true if libraries for component are shared
+#   - NetCDF_<comp>_INCLUDE_DIRS  - the include directories for specified component
+#   - NetCDF::NetCDF_<comp>       - target of component to be used with target_link_libraries()
+#
+# The following paths will be searched in order if set in CMake (first priority) or environment (second priority)
+#
+#   - NetCDF_ROOT                 - root of NetCDF installation
+#   - NetCDF_PATH                 - root of NetCDF installation
+#
+# The search process begins with locating NetCDF Include headers.  If these are in a non-standard location,
+# set one of the following CMake or environment variables to point to the location:
+#
+#  - NetCDF_INCLUDE_DIR or NetCDF_${comp}_INCLUDE_DIR
+#  - NetCDF_INCLUDE_DIRS or NetCDF_${comp}_INCLUDE_DIR
+#
+# Notes:
+#
+#   - Use "NetCDF::NetCDF_<LANG>" targets only.  NetCDF_LIBRARIES exists for backwards compatibility and should not be used.
+#     - These targets have all the knowledge of include directories and library search directories, and a single
+#       call to target_link_libraries will provide all these transitive properties to your target.  Normally all that is
+#       needed to build and link against NetCDF is, e.g.:
+#           target_link_libraries(my_c_tgt PUBLIC NetCDF::NetCDF_C)
+#   - "NetCDF" is always the preferred naming for this package, its targets, variables, and environment variables
+#     - For compatibility, some variables are also set/checked using alternate names NetCDF4, NETCDF, or NETCDF4
+#     - Environments relying on these older environment variable names should move to using a "NetCDF_ROOT" environment variable
+#   - Preferred component capitalization follows the CMake LANGUAGES variables: i.e., C, Fortran, CXX
+#     - For compatibility, alternate capitalizations are supported but should not be used.
+#   - If no components are defined, all components will be searched
+#
+
+list( APPEND _possible_components C CXX Fortran )
+
+## Include names for each component
+set( NetCDF_C_INCLUDE_NAME          netcdf.h )
+set( NetCDF_CXX_INCLUDE_NAME        netcdf )
+set( NetCDF_Fortran_INCLUDE_NAME    netcdf.mod )
+
+## Library names for each component
+set( NetCDF_C_LIBRARY_NAME          netcdf )
+set( NetCDF_CXX_LIBRARY_NAME        netcdf_c++4 )
+set( NetCDF_Fortran_LIBRARY_NAME    netcdff )
+
+## Enumerate search components
+foreach( _comp ${_possible_components} )
+  string( TOUPPER "${_comp}" _COMP )
+  set( _arg_${_COMP} ${_comp} )
+  set( _name_${_COMP} ${_comp} )
+endforeach()
+
+set( _search_components C)
+foreach( _comp ${${CMAKE_FIND_PACKAGE_NAME}_FIND_COMPONENTS} )
+  string( TOUPPER "${_comp}" _COMP )
+  set( _arg_${_COMP} ${_comp} )
+  list( APPEND _search_components ${_name_${_COMP}} )
+  if( NOT _name_${_COMP} )
+    message(SEND_ERROR "Find${CMAKE_FIND_PACKAGE_NAME}: COMPONENT ${_comp} is not a valid component. Valid components: ${_possible_components}" )
+  endif()
+endforeach()
+list( REMOVE_DUPLICATES _search_components )
+
+## Search hints for finding include directories and libraries
+foreach( _comp IN ITEMS "_" "_C_" "_Fortran_" "_CXX_" )
+  foreach( _name IN ITEMS NetCDF4 NetCDF NETCDF4 NETCDF )
+    foreach( _var IN ITEMS ROOT PATH )
+      list(APPEND _search_hints ${${_name}${_comp}${_var}} $ENV{${_name}${_comp}${_var}} )
+      list(APPEND _include_search_hints
+                ${${_name}${_comp}INCLUDE_DIR} $ENV{${_name}${_comp}INCLUDE_DIR}
+                ${${_name}${_comp}INCLUDE_DIRS} $ENV{${_name}${_comp}INCLUDE_DIRS} )
+    endforeach()
+  endforeach()
+endforeach()
+#Old-school HPC module env variable names
+foreach( _name IN ITEMS NetCDF4 NetCDF NETCDF4 NETCDF )
+  foreach( _comp IN ITEMS "_C" "_Fortran" "_CXX" )
+    list(APPEND _search_hints ${${_name}}         $ENV{${_name}})
+    list(APPEND _search_hints ${${_name}${_comp}} $ENV{${_name}${_comp}})
+  endforeach()
+endforeach()
+
+## Find headers for each component
+set(NetCDF_INCLUDE_DIRS)
+set(_new_search_components)
+foreach( _comp IN LISTS _search_components )
+  if(NOT ${PROJECT_NAME}_NetCDF_${_comp}_FOUND)
+      list(APPEND _new_search_components ${_comp})
+  endif()
+  find_file(NetCDF_${_comp}_INCLUDE_FILE
+    NAMES ${NetCDF_${_comp}_INCLUDE_NAME}
+    DOC "NetCDF ${_comp} include directory"
+    HINTS ${_include_search_hints} ${_search_hints}
+    PATH_SUFFIXES include include/netcdf
+  )
+  mark_as_advanced(NetCDF_${_comp}_INCLUDE_FILE)
+  message(DEBUG "NetCDF_${_comp}_INCLUDE_FILE: ${NetCDF_${_comp}_INCLUDE_FILE}")
+  if( NetCDF_${_comp}_INCLUDE_FILE )
+    get_filename_component(NetCDF_${_comp}_INCLUDE_FILE ${NetCDF_${_comp}_INCLUDE_FILE} ABSOLUTE)
+    get_filename_component(NetCDF_${_comp}_INCLUDE_DIR ${NetCDF_${_comp}_INCLUDE_FILE} DIRECTORY)
+    list(APPEND NetCDF_INCLUDE_DIRS ${NetCDF_${_comp}_INCLUDE_DIR})
+  endif()
+endforeach()
+if(NetCDF_INCLUDE_DIRS)
+    list(REMOVE_DUPLICATES NetCDF_INCLUDE_DIRS)
+endif()
+set(NetCDF_INCLUDE_DIRS "${NetCDF_INCLUDE_DIRS}" CACHE STRING "NetCDF Include directory paths" FORCE)
+
+## Find n*-config executables for search components
+foreach( _comp IN LISTS _search_components )
+  if( _comp MATCHES "^(C)$" )
+    set(_conf "c")
+  elseif( _comp MATCHES "^(Fortran)$" )
+    set(_conf "f")
+  elseif( _comp MATCHES "^(CXX)$" )
+    set(_conf "cxx4")
+  endif()
+  find_program( NetCDF_${_comp}_CONFIG_EXECUTABLE
+      NAMES n${_conf}-config nc-config
+    HINTS ${NetCDF_INCLUDE_DIRS} ${_include_search_hints} ${_search_hints}
+    PATH_SUFFIXES bin Bin ../bin ../../bin
+      DOC "NetCDF n${_conf}-config helper" )
+    message(DEBUG "NetCDF_${_comp}_CONFIG_EXECUTABLE: ${NetCDF_${_comp}_CONFIG_EXECUTABLE}")
+endforeach()
+
+set(_C_libs_flag --libs)
+set(_Fortran_libs_flag --flibs)
+set(_CXX_libs_flag --libs)
+set(_C_includes_flag --includedir)
+#set(_Fortran_includes_flag --includedir)
+set(_Fortran_includes_flag --fflags)
+set(_CXX_includes_flag --includedir)
+function(netcdf_config exec flag output_var)
+  set(${output_var} False PARENT_SCOPE)
+  if( exec )
+    set( ${output_var} "" PARENT_SCOPE )
+    execute_process( COMMAND ${exec} ${flag} RESULT_VARIABLE _ret OUTPUT_VARIABLE _val)
+    if( _ret EQUAL 0 )
+      string(REGEX REPLACE "(-I|-L)" "" _val "${_val}")
+      string( STRIP ${_val} _val )
+      set( ${output_var} ${_val} PARENT_SCOPE )
+    endif()
+  endif()
+endfunction()
+
+## Detect additional package properties
+netcdf_config(${NetCDF_C_CONFIG_EXECUTABLE} --has-parallel4 _val)
+if( NOT _val MATCHES "^(yes|no)$" )
+  netcdf_config(${NetCDF_C_CONFIG_EXECUTABLE} --has-parallel _val)
+endif()
+if( _val MATCHES "^(yes)$" )
+  set(NetCDF_PARALLEL TRUE CACHE STRING "NetCDF has parallel IO capability via pnetcdf or hdf5." FORCE)
+else()
+  set(NetCDF_PARALLEL FALSE CACHE STRING "NetCDF has no parallel IO capability." FORCE)
+endif()
+
+## Find libraries for each component
+set( NetCDF_LIBRARIES )
+foreach( _comp IN LISTS _search_components )
+  string( TOUPPER "${_comp}" _COMP )
+
+  find_library( NetCDF_${_comp}_LIBRARY
+    NAMES ${NetCDF_${_comp}_LIBRARY_NAME}
+    DOC "NetCDF ${_comp} library"
+    HINTS ${NetCDF_${_comp}_INCLUDE_DIRS} ${_search_hints}
+    PATH_SUFFIXES lib64 lib ../lib64 ../lib ../../lib64 ../../lib )
+  mark_as_advanced( NetCDF_${_comp}_LIBRARY )
+  get_filename_component(NetCDF_${_comp}_LIBRARY ${NetCDF_${_comp}_LIBRARY} ABSOLUTE)
+  set(NetCDF_${_comp}_LIBRARY ${NetCDF_${_comp}_LIBRARY} CACHE STRING "NetCDF ${_comp} library" FORCE)
+  message(DEBUG "NetCDF_${_comp}_LIBRARY: ${NetCDF_${_comp}_LIBRARY}")
+
+  if( NetCDF_${_comp}_LIBRARY )
+    if( NetCDF_${_comp}_LIBRARY MATCHES ".a$" )
+      set( NetCDF_${_comp}_LIBRARY_SHARED FALSE )
+      set( _library_type STATIC)
+    else()
+      list( APPEND NetCDF_LIBRARIES ${NetCDF_${_comp}_LIBRARY} )
+      set( NetCDF_${_comp}_LIBRARY_SHARED TRUE )
+      set( _library_type SHARED)
+    endif()
+  endif()
+
+  #Use nc-config to set per-component LIBRARIES variable if possible
+  netcdf_config( ${NetCDF_${_comp}_CONFIG_EXECUTABLE} ${_${_comp}_libs_flag} _val )
+  if( _val )
+    set( NetCDF_${_comp}_LIBRARIES ${_val} )
+    if(NOT NetCDF_${_comp}_LIBRARY_SHARED AND NOT NetCDF_${_comp}_FOUND) #Static targets should use nc_config to get a proper link line with all necessary static targets.
+      list( APPEND NetCDF_LIBRARIES ${NetCDF_${_comp}_LIBRARIES} )
+    endif()
+  else()
+    set( NetCDF_${_comp}_LIBRARIES ${NetCDF_${_comp}_LIBRARY} )
+    if(NOT NetCDF_${_comp}_LIBRARY_SHARED)
+      message(SEND_ERROR "Unable to properly find NetCDF.  Found static libraries at: ${NetCDF_${_comp}_LIBRARY} but could not run nc-config: ${NetCDF_CONFIG_EXECUTABLE}")
+    endif()
+  endif()
+
+  #Use nc-config to set per-component INCLUDE_DIRS variable if possible
+  netcdf_config( ${NetCDF_${_comp}_CONFIG_EXECUTABLE} ${_${_comp}_includes_flag} _val )
+  if( _val )
+    string( REPLACE " " ";" _val ${_val} )
+    set( NetCDF_${_comp}_INCLUDE_DIRS ${_val} )
+  else()
+    set( NetCDF_${_comp}_INCLUDE_DIRS ${NetCDF_${_comp}_INCLUDE_DIR} )
+  endif()
+  if(NOT NetCDF_${_comp}_FOUND)
+    list( APPEND NetCDF_INCLUDE_DIRS  ${NetCDF_${_comp}_INCLUDE_DIRS} )
+  endif()
+
+  if( NetCDF_${_comp}_LIBRARIES AND NetCDF_${_comp}_INCLUDE_DIRS )
+    set( ${CMAKE_FIND_PACKAGE_NAME}_${_arg_${_COMP}}_FOUND TRUE )
+    if (NOT TARGET NetCDF::NetCDF_${_comp})
+      add_library(NetCDF::NetCDF_${_comp} ${_library_type} IMPORTED)
+      set_target_properties(NetCDF::NetCDF_${_comp} PROPERTIES
+        IMPORTED_LOCATION ${NetCDF_${_comp}_LIBRARY}
+        INTERFACE_INCLUDE_DIRECTORIES "${NetCDF_${_comp}_INCLUDE_DIRS}"
+        INTERFACE_LINK_LIBRARIES ${NetCDF_${_comp}_LIBRARIES} )
+      if( NOT _comp MATCHES "^(C)$" )
+        target_link_libraries(NetCDF::NetCDF_${_comp} INTERFACE NetCDF::NetCDF_C)
+      endif()
+      if(MPI_${_comp}_FOUND)
+        target_link_libraries(NetCDF::NetCDF_${_comp} INTERFACE MPI::MPI_${_comp})
+      endif()
+    endif()
+  endif()
+endforeach()
+
+## Remove duplicate entries (if any) from NetCDF_INCLUDE_DIRS and NetCDF_LIBRARIES
+if(NetCDF_INCLUDE_DIRS)
+  list(REMOVE_DUPLICATES NetCDF_INCLUDE_DIRS)
+endif()
+if(NetCDF_LIBRARIES)
+  list(REMOVE_DUPLICATES NetCDF_LIBRARIES)
+endif()
+set(NetCDF_INCLUDE_DIRS "${NetCDF_INCLUDE_DIRS}" CACHE STRING "NetCDF include targets" FORCE)
+set(NetCDF_LIBRARIES "${NetCDF_LIBRARIES}" CACHE STRING "NetCDF library targets" FORCE)
+
+## Find version via netcdf-config if possible
+if (NetCDF_INCLUDE_DIRS)
+  if( NetCDF_C_CONFIG_EXECUTABLE )
+    netcdf_config( ${NetCDF_C_CONFIG_EXECUTABLE} --version _vers )
+    if( _vers )
+      string(REGEX REPLACE ".* ((([0-9]+)\\.)+([0-9]+)).*" "\\1" NetCDF_VERSION "${_vers}" )
+    endif()
+  else()
+    foreach( _dir IN LISTS NetCDF_INCLUDE_DIRS)
+      if( EXISTS "${_dir}/netcdf_meta.h" )
+        file(STRINGS "${_dir}/netcdf_meta.h" _netcdf_version_lines
+        REGEX "#define[ \t]+NC_VERSION_(MAJOR|MINOR|PATCH|NOTE)")
+        string(REGEX REPLACE ".*NC_VERSION_MAJOR *\([0-9]*\).*" "\\1" _netcdf_version_major "${_netcdf_version_lines}")
+        string(REGEX REPLACE ".*NC_VERSION_MINOR *\([0-9]*\).*" "\\1" _netcdf_version_minor "${_netcdf_version_lines}")
+        string(REGEX REPLACE ".*NC_VERSION_PATCH *\([0-9]*\).*" "\\1" _netcdf_version_patch "${_netcdf_version_lines}")
+        string(REGEX REPLACE ".*NC_VERSION_NOTE *\"\([^\"]*\)\".*" "\\1" _netcdf_version_note "${_netcdf_version_lines}")
+        set(NetCDF_VERSION "${_netcdf_version_major}.${_netcdf_version_minor}.${_netcdf_version_patch}${_netcdf_version_note}")
+        unset(_netcdf_version_major)
+        unset(_netcdf_version_minor)
+        unset(_netcdf_version_patch)
+        unset(_netcdf_version_note)
+        unset(_netcdf_version_lines)
+      endif()
+    endforeach()
+  endif()
+endif ()
+
+## Finalize find_package
+include(FindPackageHandleStandardArgs)
+
+if(NOT NetCDF_FOUND OR _new_search_components)
+    find_package_handle_standard_args( ${CMAKE_FIND_PACKAGE_NAME}
+        REQUIRED_VARS NetCDF_INCLUDE_DIRS NetCDF_LIBRARIES
+        VERSION_VAR NetCDF_VERSION
+        HANDLE_COMPONENTS )
+endif()
+
+foreach( _comp IN LISTS _search_components )
+    if( NetCDF_${_comp}_FOUND )
+        #Record found components to avoid duplication in NetCDF_LIBRARIES for static libraries
+        set(NetCDF_${_comp}_FOUND ${NetCDF_${_comp}_FOUND} CACHE BOOL "NetCDF ${_comp} Found" FORCE)
+        #Set a per-package, per-component found variable to communicate between multiple calls to find_package()
+        set(${PROJECT_NAME}_NetCDF_${_comp}_FOUND True)
+    endif()
+endforeach()
+
+if( ${CMAKE_FIND_PACKAGE_NAME}_FOUND AND NOT ${CMAKE_FIND_PACKAGE_NAME}_FIND_QUIETLY AND _new_search_components)
+  message( STATUS "Find${CMAKE_FIND_PACKAGE_NAME} defines targets:" )
+  message( STATUS "  - NetCDF_VERSION [${NetCDF_VERSION}]")
+  message( STATUS "  - NetCDF_PARALLEL [${NetCDF_PARALLEL}]")
+  foreach( _comp IN LISTS _new_search_components )
+    string( TOUPPER "${_comp}" _COMP )
+    message( STATUS "  - NetCDF_${_comp}_CONFIG_EXECUTABLE [${NetCDF_${_comp}_CONFIG_EXECUTABLE}]")
+    if( ${CMAKE_FIND_PACKAGE_NAME}_${_arg_${_COMP}}_FOUND )
+      get_filename_component(_root ${NetCDF_${_comp}_INCLUDE_DIR}/.. ABSOLUTE)
+      if( NetCDF_${_comp}_LIBRARY_SHARED )
+        message( STATUS "  - NetCDF::NetCDF_${_comp} [SHARED] [Root: ${_root}] Lib: ${NetCDF_${_comp}_LIBRARY} ")
+      else()
+        message( STATUS "  - NetCDF::NetCDF_${_comp} [STATIC] [Root: ${_root}] Lib: ${NetCDF_${_comp}_LIBRARY} ")
+      endif()
+    endif()
+  endforeach()
+endif()
+
+foreach( _prefix NetCDF NetCDF4 NETCDF NETCDF4 ${CMAKE_FIND_PACKAGE_NAME} )
+  set( ${_prefix}_INCLUDE_DIRS ${NetCDF_INCLUDE_DIRS} )
+  set( ${_prefix}_LIBRARIES    ${NetCDF_LIBRARIES})
+  set( ${_prefix}_VERSION      ${NetCDF_VERSION} )
+  set( ${_prefix}_FOUND        ${${CMAKE_FIND_PACKAGE_NAME}_FOUND} )
+  set( ${_prefix}_CONFIG_EXECUTABLE ${NetCDF_CONFIG_EXECUTABLE} )
+  set( ${_prefix}_PARALLEL ${NetCDF_PARALLEL} )
+
+  foreach( _comp ${_search_components} )
+    string( TOUPPER "${_comp}" _COMP )
+    set( _arg_comp ${_arg_${_COMP}} )
+    set( ${_prefix}_${_comp}_FOUND     ${${CMAKE_FIND_PACKAGE_NAME}_${_arg_comp}_FOUND} )
+    set( ${_prefix}_${_COMP}_FOUND     ${${CMAKE_FIND_PACKAGE_NAME}_${_arg_comp}_FOUND} )
+    set( ${_prefix}_${_arg_comp}_FOUND ${${CMAKE_FIND_PACKAGE_NAME}_${_arg_comp}_FOUND} )
+
+    set( ${_prefix}_${_comp}_LIBRARIES     ${NetCDF_${_comp}_LIBRARIES} )
+    set( ${_prefix}_${_COMP}_LIBRARIES     ${NetCDF_${_comp}_LIBRARIES} )
+    set( ${_prefix}_${_arg_comp}_LIBRARIES ${NetCDF_${_comp}_LIBRARIES} )
+
+    set( ${_prefix}_${_comp}_INCLUDE_DIRS     ${NetCDF_${_comp}_INCLUDE_DIRS} )
+    set( ${_prefix}_${_COMP}_INCLUDE_DIRS     ${NetCDF_${_comp}_INCLUDE_DIRS} )
+    set( ${_prefix}_${_arg_comp}_INCLUDE_DIRS ${NetCDF_${_comp}_INCLUDE_DIRS} )
+  endforeach()
+endforeach()
diff -uNrp NetCDF95/cmake/Modules/FindNetCDF.cmake-orig NetCDF95-mods/cmake/Modules/FindNetCDF.cmake-orig
--- NetCDF95/cmake/Modules/FindNetCDF.cmake-orig	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/cmake/Modules/FindNetCDF.cmake-orig	2020-12-12 23:33:03.260712009 -0600
@@ -0,0 +1,41 @@
+find_path(NetCDF_INCLUDE_DIR
+  NAMES netcdf.h
+  DOC "netcdf include directories")
+##mark_as_advanced(NetCDF_INCLUDE_DIR)
+
+find_library(NetCDF_LIBRARY
+  NAMES netcdf
+  DOC "netcdf library")
+##mark_as_advanced(NetCDF_LIBRARY)
+
+if (NetCDF_INCLUDE_DIR)
+  file(STRINGS "${NetCDF_INCLUDE_DIR}/netcdf_meta.h" _netcdf_version_lines
+    REGEX "#define[ \t]+NC_VERSION_(MAJOR|MINOR|PATCH|NOTE)")
+  string(REGEX REPLACE ".*NC_VERSION_MAJOR *\([0-9]*\).*" "\\1" _netcdf_version_major "${_netcdf_version_lines}")
+  string(REGEX REPLACE ".*NC_VERSION_MINOR *\([0-9]*\).*" "\\1" _netcdf_version_minor "${_netcdf_version_lines}")
+  string(REGEX REPLACE ".*NC_VERSION_PATCH *\([0-9]*\).*" "\\1" _netcdf_version_patch "${_netcdf_version_lines}")
+  string(REGEX REPLACE ".*NC_VERSION_NOTE *\"\([^\"]*\)\".*" "\\1" _netcdf_version_note "${_netcdf_version_lines}")
+  set(NetCDF_VERSION "${_netcdf_version_major}.${_netcdf_version_minor}.${_netcdf_version_patch}${_netcdf_version_note}")
+  unset(_netcdf_version_major)
+  unset(_netcdf_version_minor)
+  unset(_netcdf_version_patch)
+  unset(_netcdf_version_note)
+  unset(_netcdf_version_lines)
+endif ()
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(NetCDF
+  REQUIRED_VARS NetCDF_LIBRARY NetCDF_INCLUDE_DIR
+  VERSION_VAR NetCDF_VERSION)
+
+if (NetCDF_FOUND)
+  set(NetCDF_INCLUDE_DIRS "${NetCDF_INCLUDE_DIR}")
+  set(NetCDF_LIBRARIES "${NetCDF_LIBRARY}")
+
+  if (NOT TARGET NetCDF::NetCDF)
+    add_library(NetCDF::NetCDF UNKNOWN IMPORTED)
+    set_target_properties(NetCDF::NetCDF PROPERTIES
+      IMPORTED_LOCATION "${NetCDF_LIBRARY}"
+      INTERFACE_INCLUDE_DIRECTORIES "${NetCDF_INCLUDE_DIR}")
+  endif ()
+endif ()
diff -uNrp NetCDF95/docs/Usage/attributes.md NetCDF95-mods/docs/Usage/attributes.md
--- NetCDF95/docs/Usage/attributes.md	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/docs/Usage/attributes.md	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,83 @@
+---
+date: '2019-11-27'
+title: Attributes
+---
+
+Attributes
+===
+
+This page describles procedures handling NetCDF attributes.
+
+See the [introduction page](../introduction.md) for an explanation of
+the mnemonics "basic change", "interface change", "functionality
+change", "additional procedure".
+
+`nf95_copy_att`
+---
+
+(basic change)
+
+      subroutine nf95_copy_att(ncid_in, varid_in, name, ncid_out, varid_out, ncerr)
+        integer, intent( in):: ncid_in,  varid_in
+        character(len=*), intent( in):: name
+        integer, intent( in):: ncid_out, varid_out
+        integer, intent(out), optional:: ncerr
+
+`nf95_get_att`
+---
+
+(functionality change)
+
+      subroutine nf95_get_att(ncid, varid, name, values, ncerr)
+        integer,                          intent( in) :: ncid, varid
+        character(len = *),               intent( in) :: name
+        character(len = *), integer or real(any kind), intent(out) :: values
+        integer, intent(out), optional:: ncerr
+
+`nf95_get_att` is more secure than `nf90_get_att`. For an argument
+`values` of type `character`, `nf95_get_att` checks that the `values`
+argument is long enough and removes the null terminator, if any. For a
+numeric scalar `values` argument, `nf95_get_att` checks that the
+attribute contains a single value.
+
+`nf95_put_att`
+---
+
+(basic change)
+
+      subroutine nf95_put_att(ncid, varid, name, values, ncerr)
+        integer, intent(in) :: ncid, varid
+        character(len = *), intent(in) :: name
+        character(len = *) or integer(any kind) or real(any kind), intent(in) :: values
+        integer, intent(out), optional:: ncerr
+
+`nf95_inquire_attribute`
+---
+
+(interface change)
+
+      subroutine nf95_inquire_attribute(ncid, varid, name, xtype, nclen, attnum, &
+           ncerr)
+
+        integer,             intent( in)           :: ncid, varid
+        character (len = *), intent( in)           :: name
+        integer,             intent(out), optional :: xtype, nclen, attnum
+        integer, intent(out), optional:: ncerr
+
+The argument for the number of values or characters of the attribute is
+called `nclen` in `nf95_inquire_attribute`, instead of `len` in
+`nf90_inquire_attribute`. `len` is not a good choice for a variable name
+because it is the name of a Fortran intrinsic procedure.
+
+`nf95_get_missing`
+---
+
+(additional procedure)
+
+      subroutine nf95_get_missing(ncid, varid, missing)
+
+        integer, intent(in)::  ncid, varid
+        real or double precision, intent(out):: missing ! missing or fill value
+
+Returns the `missing_value` attribute if present, else the `_FillValue`
+if present, else `nf90_fill_real` or `nf90_fill_double`.
diff -uNrp NetCDF95/docs/Usage/datasets.md NetCDF95-mods/docs/Usage/datasets.md
--- NetCDF95/docs/Usage/datasets.md	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/docs/Usage/datasets.md	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,106 @@
+---
+date: '2019-11-27'
+title: 'Datasets & co'
+---
+
+Datasets & co
+===
+
+This page describles procedures handling a whole dataset, or handling
+a combination of NetCDF variables and dimensions.
+
+See the [introduction page](../introduction.md) for an
+explanation of the mnemonics \"basic change\", \"interface change\",
+\"functionality change\", \"additional procedure\".
+
+`nf95_close`
+---
+
+(basic change)
+
+      subroutine nf95_close(ncid, ncerr)
+        integer, intent( in) :: ncid
+        integer, intent(out), optional :: ncerr
+
+`nf95_create`
+---
+
+(basic change)
+
+      subroutine nf95_create(path, cmode, ncid, initialsize, chunksize, ncerr)
+        character (len = *), intent(in   ) :: path
+        integer,             intent(in   ) :: cmode
+        integer,             intent(  out) :: ncid
+        integer, optional,   intent(in   ) :: initialsize
+        integer, optional,   intent(inout) :: chunksize
+        integer, intent(out), optional :: ncerr
+
+`nf95_enddef`
+---
+
+(basic change)
+
+      subroutine nf95_enddef(ncid, h_minfree, v_align, v_minfree, r_align, ncerr)
+        integer,           intent( in) :: ncid
+        integer, optional, intent( in) :: h_minfree, v_align, v_minfree, r_align
+        integer, intent(out), optional :: ncerr
+
+`nf95_open`
+---
+
+(basic change)
+
+      subroutine nf95_open(path, mode, ncid, chunksize, ncerr)
+        character(len=*), intent(in):: path
+        integer, intent(in):: mode
+        integer, intent(out):: ncid
+        integer, intent(inout), optional:: chunksize
+        integer, intent(out), optional:: ncerr
+
+`nf95_redef`
+---
+
+(basic change)
+
+      subroutine nf95_redef(ncid, ncerr)
+        integer, intent( in) :: ncid
+        integer, intent(out), optional :: ncerr
+
+`nf95_inquire`
+---
+
+(basic change)
+
+      subroutine nf95_inquire(ncid, nDimensions, nVariables, nAttributes, &
+           unlimitedDimId, formatNum, ncerr)
+
+        integer,           intent( in) :: ncid
+        integer, optional, intent(out) :: nDimensions, nVariables, nAttributes
+        integer, optional, intent(out) :: unlimitedDimId, formatNum
+        integer, intent(out), optional:: ncerr
+
+`find_coord`
+---
+
+(additional procedure)
+
+      subroutine find_coord(ncid, name, dimid, varid, std_name)
+      
+        integer, intent(in):: ncid
+
+        character(len=*), intent(out), optional:: name ! blanks if not found
+        ! The actual character argument should normally have the length
+        ! "NF90_MAX_NAME".
+
+        integer, intent(out), optional:: dimid ! 0 if not found
+        integer, intent(out), optional:: varid ! 0 if not found
+
+        character(len=*), intent(in):: std_name
+        ! standard name : "plev", "latitude", "longitude" or "time"
+
+This procedure returns the name, dimension id or variable id of the
+NetCDF coordinate with standard name `std_name`, if such a coordinate
+exists. The standard name is only used to know what to search, it is not
+used for the search itself. The search itself is done via a string match
+on the attribute \"units\". So the NetCDF variable one looks for does
+not need to have the attribute `std_name`.
diff -uNrp NetCDF95/docs/Usage/dimensions.md NetCDF95-mods/docs/Usage/dimensions.md
--- NetCDF95/docs/Usage/dimensions.md	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/docs/Usage/dimensions.md	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,57 @@
+---
+date: '2010-11-04'
+title: 'Dimensions'
+---
+
+Dimensions
+===
+
+This page describles procedures handling NetCDF dimensions.
+
+See the [introduction page](../introduction.md) for an
+explanation of the mnemonics \"basic change\", \"interface change\",
+\"functionality change\", \"additional procedure\".
+
+`nf95_def_dim`
+---
+
+(interface change)
+
+      subroutine nf95_def_dim(ncid, name, nclen, dimid, ncerr)
+        integer,             intent( in) :: ncid
+        character (len = *), intent( in) :: name
+        integer,             intent( in) :: nclen
+        integer,             intent(out) :: dimid
+        integer, intent(out), optional :: ncerr
+
+The argument for the length of the dimension is called `nclen` in
+`nf95_def_dim`, instead of `len` in `nf90_def_dim`. `len` is not a good
+choice for a variable name because it is the name of a Fortran intrinsic
+procedure.
+
+`nf95_inq_dimid`
+---
+
+(basic change)
+
+      subroutine nf95_inq_dimid(ncid, name, dimid, ncerr)
+        integer,             intent(in) :: ncid
+        character (len = *), intent(in) :: name
+        integer,             intent(out) :: dimid
+        integer, intent(out), optional:: ncerr
+
+`nf95_inquire_dimension`
+---
+
+(interface change)
+
+      subroutine nf95_inquire_dimension(ncid, dimid, name, nclen, ncerr)
+        integer,                       intent( in) :: ncid, dimid
+        character (len = *), optional, intent(out) :: name
+        integer,             optional, intent(out) :: nclen
+        integer, intent(out), optional:: ncerr
+
+The argument for the length of the dimension is called `nclen` in
+`nf95_inquire_dimension`, instead of `len` in `nf90_inquire_dimension`.
+`len` is not a good choice for a variable name because it is the name of
+a Fortran intrinsic procedure.
diff -uNrp NetCDF95/docs/Usage/errors.md NetCDF95-mods/docs/Usage/errors.md
--- NetCDF95/docs/Usage/errors.md	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/docs/Usage/errors.md	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,41 @@
+---
+title: Handling of errors
+---
+
+Handling of errors
+===
+
+If you call a NetCDF95 procedure without the optional `ncerr`
+argument,and some error occurs, then the NetCDF95 procedure will :
+
+-   write to standard output all the information it has, including the
+    string produced by `nf90_strerror`;
+-   try to close the NetCDF file;
+-   stop the program, with an exit status of 1.
+
+For example, if some error occurs within a call to `nf95_inq_varid`,
+`nf95_inq_varid` will write to standard output:
+
+    nf95_inq_varid, name = < name of the variable you inquired about >:
+    < string produced by nf90_strerror >
+
+`handle_err`
+---
+
+(additional procedure)
+
+      subroutine handle_err(message, ncerr, ncid, varid)
+        character(len=*), intent(in):: message
+        integer, intent(in):: ncerr
+        integer, intent(in), optional :: ncid
+        integer, intent(in), optional :: varid
+
+This is a public procedure which is also used internally in NetCDF95. If
+there is an error (as indicated by the argument `ncerr`) then
+`handle_err` prints a message and stops the program. `handle_err` may be
+useful after calling procedures of the Fortran 90 interface that have
+not been implemented in NetCDF95.
+
+You should include the name of the calling procedure in the `message`
+argument. Provide the `ncid` argument if you want `handle_err` to try to
+close the file. Provide `varid` if you want `handle_err` to print it.
diff -uNrp NetCDF95/docs/Usage/index.md NetCDF95-mods/docs/Usage/index.md
--- NetCDF95/docs/Usage/index.md	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/docs/Usage/index.md	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,27 @@
+---
+date: '2012-01-20'
+title: Linking with NetCDF95
+---
+
+Linking with NetCDF95
+===
+
+If your program uses NetCDF95, it will require `netcdf95.mod` (and
+possibly other `.mod` files produced by compilation of NetCDF95) at
+compile time and `libnetcdf95.a` at link time. For most compilers, the
+options you will need to add are:
+
+    -I$netcdf95_inc_dir
+
+at compile time and:
+
+    -L$netcdf95_lib_dir -lnetcdf95
+
+at link time, where `$netcdf95_inc_dir` is the name of the directory
+where you put `.mod` files produced by compilation of NetCDF95 and
+`$netcdf95_lib_dir` is the name of the directory where you put
+`libnetcdf95.a`. For most compilers, you will need to place the option
+`-lnetcdf95` before the options `-lnetcdff -lnetcdf` for the NetCDF
+library. Note that NetCDF95 uses the Fortran 90 NetCDF interface, so you
+must keep the options you would use for direct access to the Fortran 90
+NetCDF interface.
diff -uNrp NetCDF95/docs/Usage/variables.md NetCDF95-mods/docs/Usage/variables.md
--- NetCDF95/docs/Usage/variables.md	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/docs/Usage/variables.md	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,171 @@
+---
+date: '2020-1-15'
+title: 'Variables'
+---
+
+Variables
+===
+
+This page describles procedures handling NetCDF variables.
+
+See the [introduction page](../introduction.md) for an explanation of
+the mnemonics "basic change", "interface change", "functionality
+change", "additional procedure".
+
+Reminder on allocatable arguments
+---
+
+Some NetCDF95 procedures below have a dummy argument with attributes
+allocatable and `intent(out)`. Recall that in this case the associated
+actual argument must also have the allocatable attribute. If it is
+allocated before the call, it will automatically be deallocated and
+reallocated in the NetCDF95 procedure.
+
+`nf95_def_var` and `nf95_def_var_scalar`
+---
+
+(interface change)
+
+      subroutine nf95_def_var_scalar(ncid, name, xtype, varid, ncerr)
+        integer,               intent( in) :: ncid
+        character (len = *),   intent( in) :: name
+        integer,               intent( in) :: xtype
+        integer,               intent(out) :: varid
+        integer, intent(out), optional:: ncerr
+
+      subroutine nf95_def_var(ncid, name, xtype, dimids, varid, ncerr)
+        integer,               intent( in) :: ncid
+        character (len = *),   intent( in) :: name
+        integer,               intent( in) :: xtype
+        integer[, dimension(:)], intent( in) :: dimids
+        integer,               intent(out) :: varid
+        integer, intent(out), optional:: ncerr
+
+(`dimids` may be either a scalar or a rank 1 array.)
+
+Because of the additional optional argument `ncerr`, the generic
+procedure name `nf95_def_var` cannot include the case of a scalar
+variable. So there is a specific public procedure `nf95_def_var_scalar`
+for this case.
+
+`nf95_get_var`
+---
+
+(functionality change)
+
+      subroutine nf95_get_var(ncid, varid, values, start, &
+           count_nc, stride, map, new_missing, ncerr)
+
+        integer, intent(in) :: ncid, varid
+        any type and any rank, intent(out):: values
+        integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+        same type as values, optional, intent(in):: new_missing
+        integer, intent(out), optional:: ncerr
+
+The argument for the number of indices selected along each dimension is
+called `count_nc` in `nf95_get_var`, instead of `count` in
+`nf90_get_var`. `count` is not a good choice for a variable name because
+it is the name of a Fortran intrinsic procedure.
+
+`nf95_get_var` checks that :
+
+-   the size of arguments `start` and `count_nc` equals the rank of the
+    NetCDF variable ;
+-   if `count_nc` is absent, the rank of argument `values` is lower than
+    or equal to the rank of the NetCDF variable.
+
+There is an optional argument, `new_missing`, which is not in the
+[Fortran 90 NetCDF
+interface](https://www.unidata.ucar.edu/software/netcdf/docs-fortran/f90_The-NetCDF-Fortran-90-Interface-Guide.html). If
+the argument `new_missing` is present then, in the returned `values`,
+the missing value from the NetCDF variable is replaced by
+`new_missing`.  This may be useful for example if, in your program,
+you need the missing value to be `ieee_value(0., IEEE_QUIET_NAN)`
+rather than `NF90_FILL_REAL`.
+
+`nf95_gw_var`
+---
+
+(additional procedure)
+
+      subroutine nf95_gw_var(ncid, varid, values)
+        integer, intent(in):: ncid
+        integer, intent(in):: varid
+        any type and kind, any rank, allocatable, intent(out):: values
+
+`nf95_gw_var` stands for "NetCDF 1995 get whole variable". This
+procedure reads a whole NetCDF variable into an array. When you want all
+the values of the NetCDF variable, this procedure is a shortcut to:
+inquiring about the dimension IDs of the variable, inquiring about the
+length of each dimension found, allocating the Fortran variable, reading
+the values from the NetCDF variable.
+
+The procedure checks that the rank of the argument `values` equals the
+rank of the NetCDF variable. The procedure does not require nor check
+that the type of `values` corresponds to the type of the NetCDF
+variable: conversion will occur if necessary.
+
+See [reminder on allocatable arguments](#reminder-on-allocatable-arguments).
+
+`nf95_inq_varid`
+---
+
+(basic change)
+
+      subroutine nf95_inq_varid(ncid, name, varid, ncerr)
+        integer,             intent(in) :: ncid
+        character (len = *), intent(in) :: name
+        integer,             intent(out) :: varid
+        integer, intent(out), optional:: ncerr
+
+`nf95_inquire_variable`
+---
+
+(functionality change)
+
+      subroutine nf95_inquire_variable(ncid, varid, name, xtype, ndims, dimids, &
+           nAtts, ncerr)
+        integer, intent(in):: ncid, varid
+        character(len = *), optional, intent(out):: name
+        integer, optional, intent(out) :: xtype, ndims
+        integer, dimension(:), optional, allocatable, intent(out) :: dimids
+        integer, optional, intent(out) :: nAtts
+        integer, intent(out), optional :: ncerr
+
+In the "new" `nf95_inquire_variable`, the argument `dimids` has the
+allocatable attribute. The procedure `nf95_inquire_variable` allocates
+and defines `dimids` if the argument is present. `dimids` is defined as
+a zero-sized array if the NetCDF variable is a scalar with no dimension.
+
+In the "old" `nf90_inquire_variable`, `dimids` was an assumed-size
+array. This was Fortran 77 style, not optimal. You had to allocate
+`dimids` in the calling procedure with a maximum possible number of
+dimensions. You also needed to call `nf90_inquire_variable` with the
+argument `ndims` present, to tell you which part of `dimids` was
+defined.
+
+See [reminder on allocatable arguments](#reminder-on-allocatable-arguments).
+
+`nf95_put_var`
+---
+
+(functionality change)
+
+      subroutine nf95_put_var(ncid, varid, values, start, &
+           count_nc, stride, map, ncerr)
+        integer,                         intent(in) :: ncid, varid
+        any type and any kind, any rank, intent(in) :: values
+        integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
+        integer, intent(out), optional:: ncerr
+
+The argument for the number of indices selected along each dimension is
+called `count_nc` in `nf95_put_var`, instead of `count` in
+`nf90_put_var`. `count` is not a good choice for a variable name because
+it is the name of a Fortran intrinsic procedure.
+
+`nf95_put_var` checks that :
+
+-   the size of arguments `start` and `count_nc` equals the rank of the
+    NetCDF variable ;
+-   if `count_nc` is absent, the rank of argument `values` is lower than
+    or equal to the rank of the NetCDF variable.
diff -uNrp NetCDF95/docs/changes.md NetCDF95-mods/docs/changes.md
--- NetCDF95/docs/changes.md	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/docs/changes.md	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,29 @@
+Changes before version control
+==============================
+
+(See [Github page](https://github.com/lguez/NetCDF95) for more recent
+changes.)
+
+-   October 12th, 2017.
+    -   NetCDF95 is now in Fortran 2003. Uses allocatable dummy
+        arguments. The actual argument of `nf95_gw_var` corresponding to
+        dummy argument `dimids` must now be allocatable and not pointer.
+        The actual argument of `nf95_inquire_variable` corresponding to
+        dummy argument `value` must now be allocatable and not pointer.
+    -   `find_coord` accepts \"plev\" as standard name.
+    -   Added specific procedure `nf95_get_var_2D_FourByteInt` to
+        generic `nf95_get_var` and specific `nf95_gw_var_int_2d `to
+        generic `nf95_gw_var`.
+-   October 10th, 2014. Added `nf95_sync`. Added specific procedure in
+    `nf95_put_var`. `nf95_get_var` and `nf95_put_var` now check that :
+    the size of arguments `start` and `count_nc` equals the rank of the
+    NetCDF variable ; if `count_nc` is absent, the rank of argument
+    `values` is lower than or equal to the rank of the NetCDF variable.
+-   February 13th, 2013, added specific procedures in `nf95_gw_var` and
+    `nf95_put_att`.
+-   March 22nd, 2012, added `nf95_inquire_attribute` and `nf95_inquire`.
+    Fixed `nf95_get_att`: does not exit if argument `ncerr` is present
+    and there is an error picked by `nf90_inquire_attribute`.
+-   January 24th, 2012, added specific procedures in `nf95_get_var` and
+    `nf95_gw_var`.
+-   November 3rd, 2010, added `nf95_get_var`.
diff -uNrp NetCDF95/docs/index.md NetCDF95-mods/docs/index.md
--- NetCDF95/docs/index.md	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/docs/index.md	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,15 @@
+---
+date: '2019-06-20'
+title: NetCDF95
+---
+
+What is it?
+===========
+
+NetCDF95 is a Fortran interface to the
+[NetCDF](http://www.unidata.ucar.edu/software/netcdf/index.html)
+library. Compared to the [Fortran 90 NetCDF
+interface](https://www.unidata.ucar.edu/software/netcdf/docs-fortran/f90_The-NetCDF-Fortran-90-Interface-Guide.html),
+the NetCDF95 interface is meant to be friendlier and more secure.
+Notably, it frees you of the cumbersome task of handling the error
+status.
diff -uNrp NetCDF95/docs/installation.md NetCDF95-mods/docs/installation.md
--- NetCDF95/docs/installation.md	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/docs/installation.md	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,106 @@
+---
+date: '2020-05-15'
+title: Installation
+---
+
+Installation
+===
+
+`NetCDF95` is written in Fortran 2003 so you need a Fortran 2003
+compiler on your machine. Moreover, you need to have the [NetCDF Fortran
+library](https://www.unidata.ucar.edu/downloads/netcdf/index.jsp)
+installed using the same Fortran compiler than the one you are going to
+use for `NetCDF95`. (Note that the NetCDF Fortran library itself
+requires prior installation of the NetCDF C library.)
+
+Get [NetCDF95 from Github](https://github.com/lguez/NetCDF95). The
+directory you get could be called NetCDF95 or NetCDF95-master (depending
+on whether you cloned or downloaded a ZIP file).
+
+Installation with CMake
+---
+
+This is the recommended way.
+
+Dependencies: you must first install [CMake](https://cmake.org/download)
+(version ≥ 3.13).
+
+1.  Type:
+
+        cd /path/to/NetCDF95
+        mkdir build
+        cd build
+            
+
+2.  Choose the installation directory `CMAKE_INSTALL_PREFIX` and type
+    the command below with your choice after `-DCMAKE_INSTALL_PREFIX=`
+    (enter an absolute path). For example, you could choose
+    `-DCMAKE_INSTALL_PREFIX=~/.local`.
+
+        cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=~/.local
+            
+
+3.  Type:
+
+        make install
+            
+
+Installation directly with make
+---
+
+This is the (old) less automated way, not recommended.
+
+1.  If you want to use a Fortran 2003 compiler other than GNU Fortran
+    then, in the file GNUmakefile, locate the line:
+
+        FC = gfortran
+
+    Replace gfortran by the command name for your compiler. Remember
+    that you need the NetCDF Fortran library installed with the chosen
+    compiler. If you have version 4.2 or later of the NetCDF Fortran
+    library installed, then the program `nf-config` should have been
+    installed with the library. This program will tell you the compiler
+    you need to use with your NetCDF Fortran library. Just type:
+
+        nf-config --fc
+
+2.  If the NetCDF Fortran library installed with the chosen compiler is
+    not in standard locations, you have to provide the locations. In
+    GNUmakefile, locate the line defining the variable
+    netcdf\_include\_dir :
+
+        netcdf_include_dir = /usr/include
+
+    Replace `/usr/include` by the path to the compiled NetCDF module
+    interfaces (usually `netcdf.mod` and `typesizes.mod`). Note that
+    NetCDF95 does not need `netcdf.inc`. If you have the command
+    `nf-config`, type:
+
+        nf-config --includedir
+
+    to find out the path you need.
+
+3.  If you want to cross-compile, you may need to choose the archiver
+    program, by setting the variable `AR`. For example, cross-compiling
+    for a NEC SX machine:
+
+        export AR=sxar
+
+4.  Optionally, you may choose additional compiler options by adding to
+    the variable `FFLAGS`. For example, you could modify the
+    optimization option `-O2`.
+5.  On MacOS, remove the letter U in the value of the variable
+    `ARFLAGS`, in `GNUmakefile`.
+6.  The makefile is written for GNU make. The command invoking GNU make
+    may be `make` or `gmake` (or `sxgmake` if you want to cross-compile
+    for NEC SX). So, for example, type:
+
+        make
+
+7.  With most compilers, `libnetcdf95.a` and `netcdf95.mod` are the only
+    files you will need, but with some compilers, you may need all the
+    `.mod` files produced by the compilation of NetCDF95. (Keep them all
+    to be on the safe side, or experiment with your compiler to see what
+    you need to keep (see [usage](Usage/index.md)).) You
+    can trash everything else (`.o` files, Fortran source files, etc.)
+    if you want.
diff -uNrp NetCDF95/docs/introduction.md NetCDF95-mods/docs/introduction.md
--- NetCDF95/docs/introduction.md	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/docs/introduction.md	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,107 @@
+---
+date: '2019-11-27'
+title: Introduction
+---
+
+Introduction
+===
+
+Two general characteristics of the [Fortran 90 NetCDF
+interface](https://www.unidata.ucar.edu/software/netcdf/docs-fortran/f90_The-NetCDF-Fortran-90-Interface-Guide.html)
+have motivated us to create a different Fortran interface to NetCDF:
+
+-   Procedures of the Fortran 90 interface are functions with side
+    effects. First, they have `intent(out)` arguments. Furthermore,
+    there is obviously data transfer inside the procedures. Any data
+    transfer inside a function is considered as a side effect. In this
+    respect, the Fortran 90 interface mimics the C interface. But
+    Fortran has a different programming style than C and frowns upon
+    side-effects in functions. See for example Metcalf and Reid (Fortran
+    90/95 Explained, 1999, §§ 5.10 and 6.10).
+-   The caller of a Fortran 90 interface procedure has to handle the
+    error status. The procedures would be friendlier if they behaved
+    like the Fortran input/output statements. That is, the error status
+    should be an optional output argument. Consider, for example, the
+    Fortran formatted `read` statement:
+
+        read([unit=]u, [fmt=]fmt [,iostat=ios] [, err=error-label] &
+           [,end=end-label]) [list]
+
+    If the `err`, `end` and `iostat` keywords are not provided, and
+    there is a problem in the execution of the `read` statement, then
+    execution of the program stops (with an informative error message
+    from the compiler). Similarly, we think NetCDF procedures should
+    have an optional argument for error status. If the optional argument
+    is absent and there is an error, then the NetCDF procedure should
+    produce an error message and stop the program. Again, here, the
+    Fortran 90 interface looks like it has been made to mimic the C
+    interface, and this is not optimal in Fortran.
+
+The NetCDF95 library provides a NetCDF interface that answers these two
+concerns.
+
+Beside the change in the two general characteristics above, there are a
+few other details in some Fortran 90 interface procedures that we change
+in the corresponding NetCDF95 procedures (cf. [description of each
+NetCDF95 procedure](Usage/index.md)). We think those
+changes make the interface easier to use and/or more secure.
+
+We give a [description of the interface of each NetCDF95
+procedure](Usage/index.md). We label each NetCDF95
+procedure with one of the following four (mutually exclusive) mnemonics:
+
+basic change
+: Means that there is a corresponding procedure in the Fortran 90
+interface and only the following three changes have been made:
+
+-   change of the name of the procedure, `nf95_` instead of `nf90_`;
+-   subroutine instead of function;
+-   additional optional argument `ncerr` for error status.
+
+Thus, for example:
+
+    function nf90_inq_varid(ncid, name, varid)
+             integer, intent(in) :: ncid
+             character (len = *), intent( in) :: name
+             integer, intent(out) :: varid
+             integer :: nf90_inq_varid
+
+becomes:
+
+    subroutine nf95_inq_varid(ncid, name, varid, ncerr)
+             integer, intent(in) :: ncid
+             character (len = *), intent( in) :: name
+             integer, intent(out) :: varid
+             integer, intent(out), optional:: ncerr
+
+interface change
+: Means that there is a corresponding procedure in the Fortran 90
+interface, and the interface of the procedure has been changed beyond
+the "basic" change described above, but there is no change in
+functionality.
+
+Procedures with interface change:
+[nf95_def_dim](Usage/dimensions.md),
+[nf95_inquire_dimension](Usage/dimensions.md),
+[nf95_def_var](Usage/variables.md) and
+[nf95_def_var_scalar](Usage/variables.md),
+[nf95_inquire_attribute](Usage/attributes.md)
+
+functionality change
+: Means that there is a corresponding procedure in the Fortran 90
+interface, the interface of the procedure has been changed and the
+functionality has also been improved.
+
+Procedures with functionality change:
+[nf95_get_var](Usage/variables.md),
+[nf95_inquire_variable](Usage/variables.md),
+[nf95_put_var](Usage/variables.md),
+[nf95_get_att](Usage/attributes.md)
+
+additional procedure
+: Means there is no corresponding procedure in the Fortran 90 interface.
+
+Additional procedures: [handle_err](Usage/datasets.md),
+[nf95_gw_var](Usage/variables.md),
+[find_coord](Usage/datasets.md),
+[nf95_get_missing](Usage/attributes.md)
diff -uNrp NetCDF95/file_list NetCDF95-mods/file_list
--- NetCDF95/file_list	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/file_list	2020-12-13 00:03:11.601458688 -0600
@@ -1,25 +1,25 @@
-check_start_count.f90
-find_coord.f90
-handle_err.f90
-netcdf95.f90
-nf95_close.f90
-nf95_copy_att.f90
-nf95_create.f90
-nf95_def_dim.f90
-nf95_def_var.f90
-nf95_enddef.f90
-nf95_get_att.f90
-nf95_get_missing.f90
-nf95_get_var.f90
-nf95_gw_var.f90
-nf95_inq_dimid.f90
-nf95_inquire_attribute.f90
-nf95_inquire_dimension.f90
-nf95_inquire.f90
-nf95_inquire_variable.f90
-nf95_inq_varid.f90
-nf95_open.f90
-nf95_put_att.f90
-nf95_put_var.f90
-nf95_redef.f90
-nf95_sync.f90
+src/find_coord.f90
+src/handle_err.f90
+src/netcdf95.f90
+src/nf95_close.f90
+src/nf95_copy_att.f90
+src/nf95_create.f90
+src/nf95_def_dim.f90
+src/nf95_def_var.f90
+src/nf95_enddef.f90
+src/nf95_get_att.f90
+src/nf95_get_missing.f90
+src/nf95_get_var.f90
+src/nf95_gw_var.f90
+src/nf95_inq_dimid.f90
+src/nf95_inquire_attribute.f90
+src/nf95_inquire_dimension.f90
+src/nf95_inquire.f90
+src/nf95_inquire_variable.f90
+src/nf95_inq_varid.f90
+src/nf95_open.f90
+src/check_start_count.f90
+src/nf95_put_att.f90
+src/nf95_put_var.f90
+src/nf95_redef.f90
+src/nf95_sync.f90
diff -uNrp NetCDF95/file_list-orig NetCDF95-mods/file_list-orig
--- NetCDF95/file_list-orig	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/file_list-orig	2020-12-13 00:02:49.333572744 -0600
@@ -0,0 +1,25 @@
+src/check_start_count.f90
+src/find_coord.f90
+src/handle_err.f90
+src/netcdf95.f90
+src/nf95_close.f90
+src/nf95_copy_att.f90
+src/nf95_create.f90
+src/nf95_def_dim.f90
+src/nf95_def_var.f90
+src/nf95_enddef.f90
+src/nf95_get_att.f90
+src/nf95_get_missing.f90
+src/nf95_get_var.f90
+src/nf95_gw_var.f90
+src/nf95_inq_dimid.f90
+src/nf95_inquire_attribute.f90
+src/nf95_inquire_dimension.f90
+src/nf95_inquire.f90
+src/nf95_inquire_variable.f90
+src/nf95_inq_varid.f90
+src/nf95_open.f90
+src/nf95_put_att.f90
+src/nf95_put_var.f90
+src/nf95_redef.f90
+src/nf95_sync.f90
diff -uNrp NetCDF95/find_coord.f90 NetCDF95-mods/find_coord.f90
--- NetCDF95/find_coord.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/find_coord.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,112 +0,0 @@
-module find_coord_m
-
-  implicit none
-
-contains
-
-  subroutine find_coord(ncid, name, dimid, varid, std_name)
-
-    ! This procedure returns the name, dimension id or variable id of
-    ! the NetCDF coordinate with standard name "std_name", if such a
-    ! coordinate exists. The standard name is only used to know what
-    ! to search, it is not used for the search itself. The search
-    ! itself is done via a string match on the attribute "units". So
-    ! the NetCDF variable one looks for does not need to have the
-    ! attribute "std_name".
-
-    use netcdf, only: NF90_MAX_NAME, NF90_NOERR
-    use nf95_get_att_m, only: nf95_get_att
-    use nf95_inq_varid_m, only: nf95_inq_varid
-    use nf95_inquire_dimension_m, only: nf95_inquire_dimension
-    use nf95_inquire_m, only: nf95_inquire
-    use nf95_inquire_variable_m, only: nf95_inquire_variable
-
-    integer, intent(in):: ncid
-
-    character(len=*), intent(out), optional:: name ! blanks if not found
-    ! The actual character argument should normally have the length
-    ! "NF90_MAX_NAME".
-
-    integer, intent(out), optional:: dimid ! 0 if not found
-    integer, intent(out), optional:: varid ! 0 if not found
-
-    character(len=*), intent(in):: std_name
-    ! standard name : "plev", "latitude", "longitude" or "time"
-
-    ! Variables local to the procedure:
-
-    character(len=13), allocatable:: units(:)
-    logical exact ! "units" must be matched exactly
-
-    integer ncerr, nDimensions, dimid_local, varid_local
-    character(len=NF90_MAX_NAME) name_local
-    integer, allocatable:: dimids(:)
-    character(len=80) values
-    logical found
-
-    !----------------------------------------------
-
-    select case (std_name)
-    case("longitude")
-       allocate(units(1))
-       units(1)="degrees_east"
-       exact=.true.
-    case("latitude")
-       allocate(units(1))
-       units(1)="degrees_north"
-       exact=.true.
-    case("time")
-       allocate(units(1))
-       units(1)=" since"
-       exact=.false.
-    case("plev")
-       allocate(units(4))
-       units = ["Pa           ", "hPa          ", "millibar     ", &
-            "mbar         "]
-       exact = .true.
-    case default
-       print *, "find_coord: bad value of std_name"
-       print *, "std_name = ", std_name
-       stop 1
-    end select
-
-    call nf95_inquire(ncid, nDimensions)
-    dimid_local = 0
-    found = .false.
-
-    ! Loop on dimensions:
-    do while (.not. found .and. dimid_local < nDimensions)
-       dimid_local = dimid_local + 1
-       call nf95_inquire_dimension(ncid, dimid_local, name_local)
-       call nf95_inq_varid(ncid, name_local, varid_local, ncerr)
-       if (ncerr == NF90_NOERR) then
-          call nf95_inquire_variable(ncid, varid_local, dimids=dimids)
-          if (size(dimids) == 1) then
-             if (dimids(1) == dimid_local) then
-                ! We have found a coordinate
-                call nf95_get_att(ncid, varid_local, "units", values, ncerr)
-                if (ncerr == NF90_NOERR)then
-                   if (exact) then
-                      found = any(values == units)
-                   else
-                      found = index(values, trim(units(1))) /= 0
-                   end if
-                end if
-             end if
-          end if
-       end if
-    end do
-
-    if (found) then
-       if (present(name)) name = name_local
-       if (present(dimid)) dimid = dimid_local
-       if (present(varid)) varid = varid_local
-    else
-       if (present(name)) name = ""
-       if (present(dimid)) dimid = 0
-       if (present(varid)) varid = 0
-    end if
-
-  end subroutine find_coord
-
-end module find_coord_m
diff -uNrp NetCDF95/handle_err.f90 NetCDF95-mods/handle_err.f90
--- NetCDF95/handle_err.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/handle_err.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,45 +0,0 @@
-module handle_err_m
-
-  implicit none
-
-contains
-
-  subroutine handle_err(message, ncerr, ncid, varid)
-
-    use netcdf, only: nf90_strerror, nf90_noerr, nf90_close
-
-    character(len=*), intent(in):: message
-    ! (should include name of calling procedure)
-
-    integer, intent(in):: ncerr
-
-    integer, intent(in), optional :: ncid
-    ! (Provide this argument if you want "handle_err" to try to close
-    ! the file.)
-
-    integer, intent(in), optional :: varid
-
-    ! Variable local to the procedure:
-    integer ncerr_close
-
-    !-------------------
-
-    if (ncerr /= nf90_noerr) then
-       print *, message, ":"
-       if (present(varid)) print *, "varid = ", varid
-       print *, trim(nf90_strerror(ncerr))
-       if (present(ncid)) then
-          ! Try to close, to leave the file in a consistent state:
-          ncerr_close = nf90_close(ncid)
-          ! (do not call "nf95_close", we do not want to recurse)
-          if (ncerr_close /= nf90_noerr) then
-             print *, "nf90_close:"
-             print *, trim(nf90_strerror(ncerr_close))
-          end if
-       end if
-       stop 1
-    end if
-
-  end subroutine handle_err
-
-end module handle_err_m
diff -uNrp NetCDF95/mkdocs.yml NetCDF95-mods/mkdocs.yml
--- NetCDF95/mkdocs.yml	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/mkdocs.yml	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,21 @@
+site_name: NetCDF95 documentation
+site_url: https://www.lmd.jussieu.fr/~lguez/NetCDF95_site/index.html
+repo_url: https://github.com/lguez/NetCDF95
+site_author: Lionel GUEZ
+nav:
+   - Home: 'https://www.lmd.jussieu.fr/~lguez/'
+   - 'index.md'
+   - 'introduction.md'
+   - 'installation.md'
+   - 'Usage':
+      - 'Usage/index.md'
+      - 'Usage/datasets.md'
+      - 'Usage/dimensions.md'
+      - 'Usage/variables.md'
+      - 'Usage/attributes.md'
+      - 'Usage/errors.md'
+   - 'changes.md'
+markdown_extensions:
+   - def_list
+   - smarty
+theme: readthedocs
diff -uNrp NetCDF95/netcdf95.f90 NetCDF95-mods/netcdf95.f90
--- NetCDF95/netcdf95.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/netcdf95.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,29 +0,0 @@
-module netcdf95
-
-  ! Author: Lionel GUEZ
-
-  use find_coord_m
-  use handle_err_m
-  use nf95_close_m
-  use nf95_copy_att_m
-  use nf95_create_m
-  use nf95_def_dim_m
-  use nf95_def_var_m
-  use nf95_enddef_m
-  use nf95_get_att_m
-  use nf95_get_missing_m
-  use nf95_get_var_m
-  use nf95_gw_var_m
-  use nf95_inq_dimid_m
-  use nf95_inq_varid_m
-  use nf95_inquire_attribute_m
-  use nf95_inquire_dimension_m
-  use nf95_inquire_m
-  use nf95_inquire_variable_m
-  use nf95_open_m
-  use nf95_put_att_m
-  use nf95_put_var_m
-  use nf95_redef_m
-  use nf95_sync_m
-
-end module netcdf95
diff -uNrp NetCDF95/nf95_close.f90 NetCDF95-mods/nf95_close.f90
--- NetCDF95/nf95_close.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_close.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,29 +0,0 @@
-module nf95_close_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_close(ncid, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_close
-
-    integer, intent( in) :: ncid
-    integer, intent(out), optional :: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_close(ncid)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_close", ncerr_not_opt)
-    end if
-
-  end subroutine nf95_close
-
-end module nf95_close_m
diff -uNrp NetCDF95/nf95_copy_att.f90 NetCDF95-mods/nf95_copy_att.f90
--- NetCDF95/nf95_copy_att.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_copy_att.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,32 +0,0 @@
-module nf95_copy_att_m
-
-  implicit none
-
-contains
-
-
-  subroutine nf95_copy_att(ncid_in, varid_in, name, ncid_out, varid_out, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_copy_att
-
-    integer, intent( in):: ncid_in,  varid_in
-    character(len=*), intent( in):: name
-    integer, intent( in):: ncid_out, varid_out
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_copy_att(ncid_in, varid_in, name, ncid_out, varid_out)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_copy_att " // name, ncerr_not_opt, ncid_out)
-    end if
-
-  end subroutine nf95_copy_att
-
-end module nf95_copy_att_m
diff -uNrp NetCDF95/nf95_create.f90 NetCDF95-mods/nf95_create.f90
--- NetCDF95/nf95_create.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_create.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,33 +0,0 @@
-module nf95_create_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_create(path, cmode, ncid, initialsize, chunksize, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_create
-
-    character (len = *), intent(in   ) :: path
-    integer,             intent(in   ) :: cmode
-    integer,             intent(  out) :: ncid
-    integer, optional,   intent(in   ) :: initialsize
-    integer, optional,   intent(inout) :: chunksize
-    integer, intent(out), optional :: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_create(path, cmode, ncid, initialsize, chunksize)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_create " // path, ncerr_not_opt)
-    end if
-
-  end subroutine nf95_create
-
-end module nf95_create_m
diff -uNrp NetCDF95/nf95_def_dim.f90 NetCDF95-mods/nf95_def_dim.f90
--- NetCDF95/nf95_def_dim.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_def_dim.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,32 +0,0 @@
-module nf95_def_dim_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_def_dim(ncid, name, nclen, dimid, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_def_dim
-
-    integer,             intent( in) :: ncid
-    character (len = *), intent( in) :: name
-    integer,             intent( in) :: nclen
-    integer,             intent(out) :: dimid
-    integer, intent(out), optional :: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_def_dim(ncid, name, nclen, dimid)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_def_dim " // name, ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_def_dim
-
-end module nf95_def_dim_m
diff -uNrp NetCDF95/nf95_def_var.f90 NetCDF95-mods/nf95_def_var.f90
--- NetCDF95/nf95_def_var.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_def_var.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,104 +0,0 @@
-module nf95_def_var_m
-
-  ! The generic procedure name "nf90_def_var" applies to
-  ! "nf90_def_var_Scalar" but we cannot apply the generic procedure name
-  ! "nf95_def_var" to "nf95_def_var_scalar" because of the additional
-  ! optional argument.
-  ! "nf95_def_var_scalar" cannot be distinguished from "nf95_def_var_oneDim".
-
-  implicit none
-
-  interface nf95_def_var
-    module procedure nf95_def_var_oneDim, nf95_def_var_ManyDims
-  end interface
-
-  private
-  public nf95_def_var, nf95_def_var_scalar
-
-contains
-
-  subroutine nf95_def_var_scalar(ncid, name, xtype, varid, ncerr)
-
-    use netcdf, only: nf90_def_var
-    use handle_err_m, only: handle_err
-
-    integer,               intent( in) :: ncid
-    character (len = *),   intent( in) :: name
-    integer,               intent( in) :: xtype
-    integer,               intent(out) :: varid
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_def_var(ncid, name, xtype, varid)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_def_var_scalar, name =  " // name, &
-            ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_def_var_scalar
-
-  !***********************
-
-  subroutine nf95_def_var_oneDim(ncid, name, xtype, dimids, varid, ncerr)
-
-    use netcdf, only: nf90_def_var
-    use handle_err_m, only: handle_err
-
-    integer,               intent( in) :: ncid
-    character (len = *),   intent( in) :: name
-    integer,               intent( in) :: xtype
-    integer,               intent( in) :: dimids
-    integer,               intent(out) :: varid
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_def_var(ncid, name, xtype, dimids, varid)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_def_var_oneDim, name =  " // name, &
-            ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_def_var_oneDim
-
-  !***********************
-
-  subroutine nf95_def_var_ManyDims(ncid, name, xtype, dimids, varid, ncerr)
-
-    use netcdf, only: nf90_def_var
-    use handle_err_m, only: handle_err
-
-    integer,               intent( in) :: ncid
-    character (len = *),   intent( in) :: name
-    integer,               intent( in) :: xtype
-    integer, dimension(:), intent( in) :: dimids
-    integer,               intent(out) :: varid
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_def_var(ncid, name, xtype, dimids, varid)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_def_var_ManyDims, name = " // name, &
-            ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_def_var_ManyDims
-
-end module nf95_def_var_m
diff -uNrp NetCDF95/nf95_enddef.f90 NetCDF95-mods/nf95_enddef.f90
--- NetCDF95/nf95_enddef.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_enddef.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,30 +0,0 @@
-module nf95_enddef_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_enddef(ncid, h_minfree, v_align, v_minfree, r_align, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_enddef
-
-    integer,           intent( in) :: ncid
-    integer, optional, intent( in) :: h_minfree, v_align, v_minfree, r_align
-    integer, intent(out), optional :: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_enddef(ncid, h_minfree, v_align, v_minfree, r_align)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_enddef", ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_enddef
-
-end module nf95_enddef_m
diff -uNrp NetCDF95/nf95_get_att.f90 NetCDF95-mods/nf95_get_att.f90
--- NetCDF95/nf95_get_att.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_get_att.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,189 +0,0 @@
-module nf95_get_att_m
-
-  use handle_err_m, only: handle_err
-  use netcdf, only: nf90_get_att, nf90_noerr
-  use nf95_inquire_attribute_m, only: nf95_inquire_attribute
-
-  implicit none
-
-  interface nf95_get_att
-     module procedure nf95_get_att_text, nf95_get_att_one_FourByteInt, &
-          nf95_get_att_one_FourByteReal, nf95_get_att_one_eightByteReal
-
-     ! The difference between the specific procedures is the type of
-     ! argument "values".
-  end interface nf95_get_att
-
-  private
-  public nf95_get_att
-
-contains
-
-  subroutine nf95_get_att_text(ncid, varid, name, values, ncerr)
-
-    integer, intent(in):: ncid, varid
-    character(len = *), intent(in):: name
-    character(len = *), intent(out):: values
-    integer, intent(out), optional:: ncerr
-
-    ! Variables local to the procedure:
-    integer ncerr_not_opt
-    integer att_len
-
-    !-------------------
-
-    ! Check that the length of "values" is large enough:
-    call nf95_inquire_attribute(ncid, varid, name, nclen=att_len, &
-         ncerr=ncerr_not_opt)
-    if (ncerr_not_opt == nf90_noerr) then
-       if (len(values) < att_len) then
-          print *, "nf95_get_att_text"
-          print *, "varid = ", varid
-          print *, "attribute name: ", name
-          print *, 'length of "values" is not large enough'
-          print *, "len(values) = ", len(values)
-          print *, "number of characters in attribute: ", att_len
-          stop 1
-       end if
-    end if
-
-    values = "" ! useless in NetCDF version 3.6.2 or better
-    ncerr_not_opt = nf90_get_att(ncid, varid, name, values)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_get_att_text " // trim(name), ncerr_not_opt, &
-            ncid, varid)
-    end if
-
-    if (att_len >= 1 .and. ncerr_not_opt == nf90_noerr) then
-       ! Remove null terminator, if any:
-       if (iachar(values(att_len:att_len)) == 0) values(att_len:att_len) = " "
-    end if
-
-  end subroutine nf95_get_att_text
-
-  !***********************
-
-  subroutine nf95_get_att_one_FourByteInt(ncid, varid, name, values, ncerr)
-
-    use typesizes, only: FourByteInt
-
-    integer, intent(in):: ncid, varid
-    character(len = *), intent(in):: name
-    integer (kind = FourByteInt), intent(out):: values
-    integer, intent(out), optional:: ncerr
-
-    ! Variables local to the procedure:
-    integer ncerr_not_opt
-    integer att_len
-
-    !-------------------
-
-    ! Check that the attribute contains a single value:
-    call nf95_inquire_attribute(ncid, varid, name, nclen=att_len, &
-         ncerr=ncerr_not_opt)
-    if (ncerr_not_opt == nf90_noerr) then
-       if (att_len /= 1) then
-          print *, "nf95_get_att_one_FourByteInt"
-          print *, "varid = ", varid
-          print *, "attribute name: ", name
-          print *, 'the attribute does not contain a single value'
-          print *, "number of values in attribute: ", att_len
-          stop 1
-       end if
-    end if
-
-    ncerr_not_opt = nf90_get_att(ncid, varid, name, values)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_get_att_one_FourByteInt " // trim(name), &
-            ncerr_not_opt, ncid, varid)
-    end if
-
-  end subroutine nf95_get_att_one_FourByteInt
-
-  !***********************
-
-  subroutine nf95_get_att_one_FourByteReal(ncid, varid, name, values, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer, intent(in):: ncid, varid
-    character(len = *), intent(in):: name
-    real (kind = FourByteReal), intent(out):: values
-    integer, intent(out), optional:: ncerr
-
-    ! Variables local to the procedure:
-    integer ncerr_not_opt
-    integer att_len
-
-    !-------------------
-
-    ! Check that the attribute contains a single value:
-    call nf95_inquire_attribute(ncid, varid, name, nclen=att_len, &
-         ncerr=ncerr_not_opt)
-    if (ncerr_not_opt == nf90_noerr) then
-       if (att_len /= 1) then
-          print *, "nf95_get_att_one_Fourbytereal"
-          print *, "varid = ", varid
-          print *, "attribute name: ", name
-          print *, 'the attribute does not contain a single value'
-          print *, "number of values in attribute: ", att_len
-          stop 1
-       end if
-    end if
-
-    ncerr_not_opt = nf90_get_att(ncid, varid, name, values)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_get_att_one_Fourbytereal " // trim(name), &
-            ncerr_not_opt, ncid, varid)
-    end if
-
-  end subroutine nf95_get_att_one_Fourbytereal
-
-  !***********************
-
-  subroutine nf95_get_att_one_EightByteReal(ncid, varid, name, values, ncerr)
-
-    use typesizes, only: EightByteReal
-
-    integer, intent(in):: ncid, varid
-    character(len = *), intent(in):: name
-    real (kind = EightByteReal), intent(out):: values
-    integer, intent(out), optional:: ncerr
-
-    ! Variables local to the procedure:
-    integer ncerr_not_opt
-    integer att_len
-
-    !-------------------
-
-    ! Check that the attribute contains a single value:
-    call nf95_inquire_attribute(ncid, varid, name, nclen=att_len, &
-         ncerr=ncerr_not_opt)
-    if (ncerr_not_opt == nf90_noerr) then
-       if (att_len /= 1) then
-          print *, "nf95_get_att_one_Eightbytereal"
-          print *, "varid = ", varid
-          print *, "attribute name: ", name
-          print *, 'the attribute does not contain a single value'
-          print *, "number of values in attribute: ", att_len
-          stop 1
-       end if
-    end if
-
-    ncerr_not_opt = nf90_get_att(ncid, varid, name, values)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_get_att_one_Eightbytereal " // trim(name), &
-            ncerr_not_opt, ncid, varid)
-    end if
-
-  end subroutine nf95_get_att_one_Eightbytereal
-
-end module nf95_get_att_m
diff -uNrp NetCDF95/nf95_get_missing.f90 NetCDF95-mods/nf95_get_missing.f90
--- NetCDF95/nf95_get_missing.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_get_missing.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,91 +0,0 @@
-module nf95_get_missing_m
-
-  use netcdf, only: nf90_noerr
-  use nf95_get_att_m, only: nf95_get_att
-
-  implicit none
-
-  interface nf95_get_missing
-     module procedure nf95_get_missing_real, nf95_get_missing_dble, &
-          nf95_get_missing_int
-  end interface nf95_get_missing
-
-  private
-  public nf95_get_missing
-
-contains
-
-  subroutine nf95_get_missing_real(ncid, varid, missing)
-
-    use netcdf, only: NF90_FILL_REAL
-
-    integer, intent(in)::  ncid, varid
-    real, intent(out):: missing ! missing or fill value
-
-    ! Local:
-    integer ncerr
-
-    !-------------------------------------------------------------------
-
-    call nf95_get_att(ncid, varid, name = "missing_value", values = missing, &
-         ncerr = ncerr)
-
-    if (ncerr /= nf90_noerr) then
-       call nf95_get_att(ncid, varid, name = "_FillValue", values = missing, &
-            ncerr = ncerr)
-       if (ncerr /= nf90_noerr) missing = NF90_FILL_REAL
-    end if
-
-  end subroutine nf95_get_missing_real
-
-  !**************************************************************************
-
-  subroutine nf95_get_missing_dble(ncid, varid, missing)
-
-    use netcdf, only: NF90_FILL_double
-
-    integer, intent(in)::  ncid, varid
-    double precision, intent(out):: missing ! missing or fill value
-
-    ! Local:
-    integer ncerr
-
-    !-------------------------------------------------------------------
-
-    call nf95_get_att(ncid, varid, name = "missing_value", values = missing, &
-         ncerr = ncerr)
-
-    if (ncerr /= nf90_noerr) then
-       call nf95_get_att(ncid, varid, name = "_FillValue", values = missing, &
-            ncerr = ncerr)
-       if (ncerr /= nf90_noerr) missing = NF90_FILL_double
-    end if
-
-  end subroutine nf95_get_missing_dble
-
-  !**************************************************************************
-
-  subroutine nf95_get_missing_int(ncid, varid, missing)
-
-    use netcdf, only: NF90_FILL_INT
-
-    integer, intent(in)::  ncid, varid
-    integer, intent(out):: missing ! missing or fill value
-
-    ! Local:
-    integer ncerr
-
-    !-------------------------------------------------------------------
-
-    call nf95_get_att(ncid, varid, name = "missing_value", values = missing, &
-         ncerr = ncerr)
-
-    if (ncerr /= nf90_noerr) then
-       call nf95_get_att(ncid, varid, name = "_FillValue", values = missing, &
-            ncerr = ncerr)
-       if (ncerr /= nf90_noerr) missing = NF90_FILL_INT
-    end if
-
-  end subroutine nf95_get_missing_int
-
-end module nf95_get_missing_m
diff -uNrp NetCDF95/nf95_get_var.f90 NetCDF95-mods/nf95_get_var.f90
--- NetCDF95/nf95_get_var.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_get_var.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,398 +0,0 @@
-module nf95_get_var_m
-
-  use netcdf, only: nf90_get_var, NF90_NOERR
-  
-  use handle_err_m, only: handle_err
-  use check_start_count_m, only: check_start_count
-  use nf95_get_missing_m, only: nf95_get_missing
-
-  implicit none
-
-  interface nf95_get_var
-     module procedure nf95_get_var_FourByteReal, nf95_get_var_FourByteInt, &
-          nf95_get_var_1D_FourByteReal, nf95_get_var_1D_FourByteInt, &
-          nf95_get_var_1D_EightByteReal, nf95_get_var_2D_FourByteReal, &
-          nf95_get_var_2D_EightByteReal, nf95_get_var_2D_FourByteInt, &
-          nf95_get_var_3D_FourByteInt, nf95_get_var_3D_FourByteReal, &
-          nf95_get_var_3D_EightByteReal, nf95_get_var_4D_FourByteReal, &
-          nf95_get_var_4D_EightByteReal, nf95_get_var_5D_FourByteReal, &
-          nf95_get_var_5D_EightByteReal
-  end interface
-
-  private
-  public nf95_get_var
-
-  integer ncerr_not_opt
-
-contains
-
-  subroutine nf95_get_var_FourByteReal(ncid, varid, values, start, &
-       new_missing, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer, intent(in):: ncid, varid
-    real(kind = FourByteReal), intent(out):: values
-    integer, dimension(:), optional, intent(in):: start
-    real(kind = FourByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = "nf95_get_var_FourByteReal"
-    real(kind = FourByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_scalar.h"
-
-  end subroutine nf95_get_var_FourByteReal
-
-  !***********************
-
-  subroutine nf95_get_var_FourByteInt(ncid, varid, values, start, &
-       new_missing, ncerr)
-
-    use typesizes, only: FourByteInt
-
-    integer, intent(in):: ncid, varid
-    integer(kind = FourByteInt), intent(out):: values
-    integer, dimension(:), optional, intent(in):: start
-    integer(kind = FourByteInt), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = "nf95_get_var_FourByteInt"
-    integer(kind = FourByteInt) missing
-    
-    !-------------------
-
-    include "nf95_get_var_scalar.h"
-
-  end subroutine nf95_get_var_FourByteInt
-
-  !***********************
-
-  subroutine nf95_get_var_1D_FourByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer,                         intent(in):: ncid, varid
-    real(kind = FourByteReal), intent(out):: values(:)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    real(kind = FourByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_1D_FourByteReal"
-    integer, parameter:: rank_values = 1
-    real(kind = FourByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_1D_FourByteReal
-
-  !***********************
-
-  subroutine nf95_get_var_1D_FourByteInt(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: FourByteInt
-
-    integer,                         intent(in):: ncid, varid
-    integer(kind = FourByteInt), intent(out):: values(:)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    integer(kind = FourByteInt), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_1D_FourByteInt"
-    integer, parameter:: rank_values = 1
-    integer(kind = FourByteInt) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_1D_FourByteInt
-
-  !***********************
-
-  subroutine nf95_get_var_1D_EightByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: eightByteReal
-
-    integer,                         intent(in):: ncid, varid
-    real(kind = EightByteReal),     intent(out):: values(:)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    real(kind = EightByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_1D_EightByteReal"
-    integer, parameter:: rank_values = 1
-    real(kind = EightByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_1D_EightByteReal
-
-  !***********************
-
-  subroutine nf95_get_var_2D_FourByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer,                         intent(in):: ncid, varid
-    real(kind = FourByteReal), intent(out):: values(:, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    real(kind = FourByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_2D_FourByteReal"
-    integer, parameter:: rank_values = 2
-    real(kind = FourByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_2D_FourByteReal
-
-  !***********************
-
-  subroutine nf95_get_var_2D_EightByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: EightByteReal
-
-    integer,                         intent(in):: ncid, varid
-    real(kind = EightByteReal), intent(out):: values(:, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    real(kind = EightByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_2D_EightByteReal"
-    integer, parameter:: rank_values = 2
-    real(kind = EightByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_2D_EightByteReal
-
-  !***********************
-
-  subroutine nf95_get_var_2D_FourByteInt(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: FourByteInt
-
-    integer, intent(in):: ncid, varid
-    integer(kind = FourByteInt), intent(out):: values(:, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    integer(kind = FourByteInt), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_2D_FourByteInt"
-    integer, parameter:: rank_values = 2
-    integer(kind = FourByteInt) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_2D_FourByteInt
-
-  !***********************
-
-  subroutine nf95_get_var_3D_FourByteInt(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: FourByteInt
-
-    integer, intent(in):: ncid, varid
-    integer(kind = FourByteInt), intent(out):: values(:, :, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    integer(kind = FourByteInt), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_3D_FourByteInt"
-    integer, parameter:: rank_values = 3
-    integer(kind = FourByteInt) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_3D_FourByteInt
-
-  !***********************
-
-  subroutine nf95_get_var_3D_FourByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer,                         intent(in):: ncid, varid
-    real(kind = FourByteReal), intent(out):: values(:, :, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    real(kind = FourByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_3D_FourByteReal"
-    integer, parameter:: rank_values = 3
-    real(kind = FourByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_3D_FourByteReal
-
-  !***********************
-
-  subroutine nf95_get_var_3D_EightByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: eightByteReal
-
-    integer,                         intent(in):: ncid, varid
-    real(kind = EightByteReal),     intent(out):: values(:, :, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    real(kind = EightByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_3D_EightByteReal"
-    integer, parameter:: rank_values = 3
-    real(kind = EightByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_3D_EightByteReal
-
-  !***********************
-
-  subroutine nf95_get_var_4D_FourByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer,                         intent(in):: ncid, varid
-    real(kind = FourByteReal), intent(out):: values(:, :, :, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    real(kind = FourByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_4D_FourByteReal"
-    integer, parameter:: rank_values = 4
-    real(kind = FourByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_4D_FourByteReal
-
-  !***********************
-
-  subroutine nf95_get_var_4D_EightByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: EightByteReal
-
-    integer, intent(in):: ncid, varid
-    real(kind = EightByteReal), intent(out):: values(:, :, :, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    real(kind = EightByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_4D_EightByteReal"
-    integer, parameter:: rank_values = 4
-    real(kind = EightByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_4D_EightByteReal
-
-  !***********************
-
-  subroutine nf95_get_var_5D_FourByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer, intent(in):: ncid, varid
-    real(kind = FourByteReal), intent(out):: values(:, :, :, :, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    real(kind = FourByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_5D_FourByteReal"
-    integer, parameter:: rank_values = 5
-    real(kind = FourByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_5D_FourByteReal
-
-  !***********************
-
-  subroutine nf95_get_var_5D_EightByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, new_missing, ncerr)
-
-    use typesizes, only: EightByteReal
-
-    integer, intent(in):: ncid, varid
-    real(kind = EightByteReal), intent(out):: values(:, :, :, :, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    real(kind = EightByteReal), optional, intent(in):: new_missing
-    integer, intent(out), optional:: ncerr
-
-    ! Local:
-    character(len=*), parameter:: procedure_name = &
-         "nf95_get_var_5D_EightByteReal"
-    integer, parameter:: rank_values = 5
-    real(kind = EightByteReal) missing
-
-    !-------------------
-
-    include "nf95_get_var_array.h"
-
-  end subroutine nf95_get_var_5D_EightByteReal
-
-end module nf95_get_var_m
diff -uNrp NetCDF95/nf95_get_var_array.h NetCDF95-mods/nf95_get_var_array.h
--- NetCDF95/nf95_get_var_array.h	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_get_var_array.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,20 +0,0 @@
-  ! -*- mode: f90; -*-
-  
-  ! Body of specific procedures of generic interface "nf95_get_var",
-  ! with array argument "values".
-  
-  call check_start_count(procedure_name, ncid, varid, start, count_nc, &
-       rank_values)
-  ncerr_not_opt = nf90_get_var(ncid, varid, values, start, count_nc, stride, &
-       map)
-
-  if (present(ncerr)) then
-     ncerr = ncerr_not_opt
-  else
-     call handle_err(procedure_name, ncerr_not_opt, ncid, varid)
-  end if
-
-  if (ncerr_not_opt == NF90_NOERR .and. present(new_missing)) then
-     call nf95_get_missing(ncid, varid, missing)
-     where (values == missing) values = new_missing
-  end if
diff -uNrp NetCDF95/nf95_get_var_scalar.h NetCDF95-mods/nf95_get_var_scalar.h
--- NetCDF95/nf95_get_var_scalar.h	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_get_var_scalar.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,18 +0,0 @@
-  ! -*- mode: f90; -*-
-  
-  ! Body of specific procedures of generic interface "nf95_get_var",
-  ! with scalar argument "values".
-  
-  call check_start_count(procedure_name, ncid, varid, start, rank_values = 0)
-  ncerr_not_opt = nf90_get_var(ncid, varid, values, start)
-
-  if (present(ncerr)) then
-     ncerr = ncerr_not_opt
-  else
-     call handle_err(procedure_name, ncerr_not_opt, ncid, varid)
-  end if
-
-  if (ncerr_not_opt == NF90_NOERR .and. present(new_missing)) then
-     call nf95_get_missing(ncid, varid, missing)
-     if (values == missing) values = new_missing
-  end if
diff -uNrp NetCDF95/nf95_gw_var.f90 NetCDF95-mods/nf95_gw_var.f90
--- NetCDF95/nf95_gw_var.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_gw_var.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,429 +0,0 @@
-module nf95_gw_var_m
-
-  use nf95_get_var_m, only: NF95_GET_VAR
-  use nf95_inquire_variable_m, only: nf95_inquire_variable
-  use nf95_inquire_dimension_m, only: nf95_inquire_dimension
-
-  implicit none
-
-  interface nf95_gw_var
-     ! "nf95_gw_var" stands for "NetCDF 1995 get whole variable".
-     ! These procedures read a whole NetCDF variable (coordinate or
-     ! primary) into an array.
-     ! The difference between the procedures is the rank and type of
-     ! argument "values".
-     ! The procedures do not check the type of the NetCDF variable.
-
-     module procedure nf95_gw_var_real_1d, nf95_gw_var_real_2d, &
-          nf95_gw_var_real_3d, nf95_gw_var_real_4d, nf95_gw_var_real_5d, &
-          nf95_gw_var_dble_1d, nf95_gw_var_dble_2d, nf95_gw_var_dble_3d, &
-          nf95_gw_var_dble_4d, nf95_gw_var_int_1d, nf95_gw_var_int_2d, &
-          nf95_gw_var_int_3d
-  end interface
-
-  private
-  public nf95_gw_var
-
-contains
-
-  subroutine nf95_gw_var_real_1d(ncid, varid, values)
-
-    ! Real type, the array has rank 1.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    real, allocatable, intent(out):: values(:)
-
-    ! Variables local to the procedure:
-    integer nclen
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 1) then
-       print *, "nf95_gw_var_real_1d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 1"
-       stop 1
-    end if
-
-    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen)
-
-    allocate(values(nclen))
-    if (nclen /= 0) call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_real_1d
-
-  !************************************
-
-  subroutine nf95_gw_var_real_2d(ncid, varid, values)
-
-    ! Real type, the array has rank 2.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    real, allocatable, intent(out):: values(:, :)
-
-    ! Variables local to the procedure:
-    integer nclen1, nclen2
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 2) then
-       print *, "nf95_gw_var_real_2d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 2"
-       stop 1
-    end if
-
-    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
-    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
-
-    allocate(values(nclen1, nclen2))
-    if (nclen1 /= 0 .and. nclen2 /= 0) call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_real_2d
-
-  !************************************
-
-  subroutine nf95_gw_var_real_3d(ncid, varid, values)
-
-    ! Real type, the array has rank 3.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    real, allocatable, intent(out):: values(:, :, :)
-
-    ! Variables local to the procedure:
-    integer nclen1, nclen2, nclen3
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 3) then
-       print *, "nf95_gw_var_real_3d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 3"
-       stop 1
-    end if
-
-    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
-    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
-    call nf95_inquire_dimension(ncid, dimids(3), nclen=nclen3)
-
-    allocate(values(nclen1, nclen2, nclen3))
-    if (nclen1 /= 0 .and. nclen2 /= 0 .and. nclen3 /= 0) &
-         call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_real_3d
-
-  !************************************
-
-  subroutine nf95_gw_var_real_4d(ncid, varid, values)
-
-    ! Real type, the array has rank 4.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    real, allocatable, intent(out):: values(:, :, :, :)
-
-    ! Variables local to the procedure:
-    integer len_dim(4), i
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 4) then
-       print *, "nf95_gw_var_real_4d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 4"
-       stop 1
-    end if
-
-    do i = 1, 4
-       call nf95_inquire_dimension(ncid, dimids(i), nclen=len_dim(i))
-    end do
-
-    allocate(values(len_dim(1), len_dim(2), len_dim(3), len_dim(4)))
-    if (all(len_dim /= 0)) call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_real_4d
-
-  !************************************
-
-  subroutine nf95_gw_var_real_5d(ncid, varid, values)
-
-    ! Real type, the array has rank 5.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    real, allocatable, intent(out):: values(:, :, :, :, :)
-
-    ! Variables local to the procedure:
-    integer len_dim(5), i
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 5) then
-       print *, "nf95_gw_var_real_5d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 5"
-       stop 1
-    end if
-
-    do i = 1, 5
-       call nf95_inquire_dimension(ncid, dimids(i), nclen=len_dim(i))
-    end do
-
-    allocate(values(len_dim(1), len_dim(2), len_dim(3), len_dim(4), len_dim(5)))
-    if (all(len_dim /= 0)) call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_real_5d
-
-  !************************************
-
-  subroutine nf95_gw_var_dble_1d(ncid, varid, values)
-
-    ! Double precision, the array has rank 1.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    double precision, allocatable, intent(out):: values(:)
-
-    ! Variables local to the procedure:
-    integer nclen
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 1) then
-       print *, "nf95_gw_var_dble_1d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 1"
-        stop 1
-    end if
-
-    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen)
-
-    allocate(values(nclen))
-    if (nclen /= 0) call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_dble_1d
-
-  !************************************
-
-  subroutine nf95_gw_var_dble_2d(ncid, varid, values)
-
-    ! Double precision, the array has rank 2.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    double precision, allocatable, intent(out):: values(:, :)
-
-    ! Variables local to the procedure:
-    integer nclen1, nclen2
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 2) then
-       print *, "nf95_gw_var_dble_2d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 2"
-       stop 1
-    end if
-
-    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
-    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
-
-    allocate(values(nclen1, nclen2))
-    if (nclen1 /= 0 .and. nclen2 /= 0) call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_dble_2d
-
-  !************************************
-
-  subroutine nf95_gw_var_dble_3d(ncid, varid, values)
-
-    ! Double precision, the array has rank 3.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    double precision, allocatable, intent(out):: values(:, :, :)
-
-    ! Variables local to the procedure:
-    integer nclen1, nclen2, nclen3
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 3) then
-       print *, "nf95_gw_var_dble_3d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 3"
-       stop 1
-    end if
-
-    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
-    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
-    call nf95_inquire_dimension(ncid, dimids(3), nclen=nclen3)
-
-    allocate(values(nclen1, nclen2, nclen3))
-    if (nclen1 /= 0 .and. nclen2 /= 0 .and. nclen3 /= 0) &
-         call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_dble_3d
-
-  !************************************
-
-  subroutine nf95_gw_var_dble_4d(ncid, varid, values)
-
-    ! Double precision, the array has rank 4.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    double precision, allocatable, intent(out):: values(:, :, :, :)
-
-    ! Variables local to the procedure:
-    integer len_dim(4), i
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 4) then
-       print *, "nf95_gw_var_dble_4d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 4"
-       stop 1
-    end if
-
-    do i = 1, 4
-       call nf95_inquire_dimension(ncid, dimids(i), nclen=len_dim(i))
-    end do
-
-    allocate(values(len_dim(1), len_dim(2), len_dim(3), len_dim(4)))
-    if (all(len_dim /= 0)) call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_dble_4d
-
-  !************************************
-
-  subroutine nf95_gw_var_int_1d(ncid, varid, values)
-
-    ! Integer type, the array has rank 1.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    integer, allocatable, intent(out):: values(:)
-
-    ! Variables local to the procedure:
-    integer nclen
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 1) then
-       print *, "nf95_gw_var_int_1d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 1"
-       stop 1
-    end if
-
-    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen)
-
-    allocate(values(nclen))
-    if (nclen /= 0) call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_int_1d
-
-  !************************************
-
-  subroutine nf95_gw_var_int_2d(ncid, varid, values)
-
-    ! Integer type, the array has rank 2.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    integer, allocatable, intent(out):: values(:, :)
-
-    ! Variables local to the procedure:
-    integer nclen1, nclen2
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 2) then
-       print *, "nf95_gw_var_int_2d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 2"
-       stop 1
-    end if
-
-    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
-    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
-
-    allocate(values(nclen1, nclen2))
-    if (nclen1 /= 0 .and. nclen2 /= 0) call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_int_2d
-
-  !************************************
-
-  subroutine nf95_gw_var_int_3d(ncid, varid, values)
-
-    ! Integer type, the array has rank 3.
-
-    integer, intent(in):: ncid
-    integer, intent(in):: varid
-    integer, allocatable, intent(out):: values(:, :, :)
-
-    ! Variables local to the procedure:
-    integer nclen1, nclen2, nclen3
-    integer, allocatable:: dimids(:)
-
-    !---------------------
-
-    call nf95_inquire_variable(ncid, varid, dimids=dimids)
-
-    if (size(dimids) /= 3) then
-       print *, "nf95_gw_var_int_3d:"
-       print *, "varid = ", varid
-       print *, "rank of NetCDF variable is ", size(dimids), ", not 3"
-       stop 1
-    end if
-
-    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
-    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
-    call nf95_inquire_dimension(ncid, dimids(3), nclen=nclen3)
-
-    allocate(values(nclen1, nclen2, nclen3))
-    if (nclen1 /= 0 .and. nclen2 /= 0 .and. nclen3 /= 0) &
-         call NF95_GET_VAR(ncid, varid, values)
-
-  end subroutine nf95_gw_var_int_3d
-
-end module nf95_gw_var_m
diff -uNrp NetCDF95/nf95_inq_dimid.f90 NetCDF95-mods/nf95_inq_dimid.f90
--- NetCDF95/nf95_inq_dimid.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_inq_dimid.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,31 +0,0 @@
-module nf95_inq_dimid_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_inq_dimid(ncid, name, dimid, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_inq_dimid
-
-    integer,             intent(in) :: ncid
-    character (len = *), intent(in) :: name
-    integer,             intent(out) :: dimid
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_inq_dimid(ncid, name, dimid)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_inq_dimid " // name, ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_inq_dimid
-
-end module nf95_inq_dimid_m
diff -uNrp NetCDF95/nf95_inq_varid.f90 NetCDF95-mods/nf95_inq_varid.f90
--- NetCDF95/nf95_inq_varid.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_inq_varid.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,31 +0,0 @@
-module nf95_inq_varid_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_inq_varid(ncid, name, varid, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_inq_varid
-
-    integer,             intent(in) :: ncid
-    character(len=*), intent(in):: name
-    integer,             intent(out) :: varid
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_inq_varid(ncid, name, varid)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_inq_varid, name = " // name, ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_inq_varid
-
-end module nf95_inq_varid_m
diff -uNrp NetCDF95/nf95_inquire.f90 NetCDF95-mods/nf95_inquire.f90
--- NetCDF95/nf95_inquire.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_inquire.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,34 +0,0 @@
-module nf95_inquire_m
-
-  implicit none
-
-contains
-
-
-  subroutine nf95_inquire(ncid, nDimensions, nVariables, nAttributes, &
-       unlimitedDimId, formatNum, ncerr)
-    
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_inquire
-
-    integer,           intent( in) :: ncid
-    integer, optional, intent(out) :: nDimensions, nVariables, nAttributes
-    integer, optional, intent(out) :: unlimitedDimId, formatNum
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_inquire(ncid, nDimensions, nVariables, nAttributes, &
-         unlimitedDimId, formatNum)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_inquire", ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_inquire
-
-end module nf95_inquire_m
diff -uNrp NetCDF95/nf95_inquire_attribute.f90 NetCDF95-mods/nf95_inquire_attribute.f90
--- NetCDF95/nf95_inquire_attribute.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_inquire_attribute.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,35 +0,0 @@
-module nf95_inquire_attribute_m
-
-  implicit none
-
-contains
-
-
-  subroutine nf95_inquire_attribute(ncid, varid, name, xtype, nclen, attnum, &
-       ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_inquire_attribute
-
-    integer,             intent( in)           :: ncid, varid
-    character (len = *), intent( in)           :: name
-    integer,             intent(out), optional :: xtype, nclen, attnum
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_inquire_attribute(ncid, varid, name, xtype, nclen, &
-         attnum)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_inquire_attribute " // name, ncerr_not_opt, &
-            ncid, varid)
-    end if
-
-  end subroutine nf95_inquire_attribute
-
-end module nf95_inquire_attribute_m
diff -uNrp NetCDF95/nf95_inquire_dimension.f90 NetCDF95-mods/nf95_inquire_dimension.f90
--- NetCDF95/nf95_inquire_dimension.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_inquire_dimension.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,31 +0,0 @@
-module nf95_inquire_dimension_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_inquire_dimension(ncid, dimid, name, nclen, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_inquire_dimension
-
-    integer,                       intent( in) :: ncid, dimid
-    character (len = *), optional, intent(out) :: name
-    integer,             optional, intent(out) :: nclen
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_inquire_dimension(ncid, dimid, name, nclen)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_inquire_dimension", ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_inquire_dimension
-
-end module nf95_inquire_dimension_m
diff -uNrp NetCDF95/nf95_inquire_variable.f90 NetCDF95-mods/nf95_inquire_variable.f90
--- NetCDF95/nf95_inquire_variable.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_inquire_variable.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,52 +0,0 @@
-module nf95_inquire_variable_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_inquire_variable(ncid, varid, name, xtype, ndims, dimids, &
-       nAtts, ncerr)
-
-    ! In "nf90_inquire_variable", "dimids" is an assumed-size array.
-    ! This is not optimal.
-    ! We are in the classical case of an array the size of which is
-    ! unknown in the calling procedure, before the call.
-    ! Here we use a better solution: an allocatable argument array.
-    ! This procedure allocates and defines "dimids" if it is present.
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_inquire_variable, nf90_max_var_dims
-
-    integer, intent(in):: ncid, varid
-    character(len = *), optional, intent(out):: name
-    integer, optional, intent(out) :: xtype, ndims
-    integer, optional, allocatable, intent(out) :: dimids(:)
-    integer, optional, intent(out) :: nAtts
-    integer, intent(out), optional :: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-    integer dimids_local(nf90_max_var_dims)
-    integer ndims_not_opt
-
-    !-------------------
-
-    if (present(dimids)) then
-       ncerr_not_opt = nf90_inquire_variable(ncid, varid, name, xtype, &
-            ndims_not_opt, dimids_local, nAtts)
-       dimids = dimids_local(:ndims_not_opt) ! also works if ndims_not_opt == 0
-       if (present(ndims)) ndims = ndims_not_opt
-    else
-       ncerr_not_opt = nf90_inquire_variable(ncid, varid, name, xtype, ndims, &
-            nAtts=nAtts)
-    end if
-
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_inquire_variable", ncerr_not_opt, ncid, varid)
-    end if
-
-  end subroutine nf95_inquire_variable
-
-end module nf95_inquire_variable_m
diff -uNrp NetCDF95/nf95_open.f90 NetCDF95-mods/nf95_open.f90
--- NetCDF95/nf95_open.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_open.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,32 +0,0 @@
-module nf95_open_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_open(path, mode, ncid, chunksize, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_open
-
-    character(len=*), intent(in):: path
-    integer, intent(in):: mode
-    integer, intent(out):: ncid
-    integer, intent(inout), optional:: chunksize
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_open(path, mode, ncid, chunksize)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_open " // path, ncerr_not_opt)
-    end if
-
-  end subroutine nf95_open
-
-end module nf95_open_m
diff -uNrp NetCDF95/nf95_put_att.f90 NetCDF95-mods/nf95_put_att.f90
--- NetCDF95/nf95_put_att.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_put_att.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,96 +0,0 @@
-module nf95_put_att_m
-
-  implicit none
-
-  interface nf95_put_att
-     module procedure nf95_put_att_text, nf95_put_att_one_FourByteInt, &
-          nf95_put_att_one_FourByteReal
-  end interface
-
-  private
-  public nf95_put_att
-
-contains
-
-  subroutine nf95_put_att_text(ncid, varid, name, values, ncerr)
-
-    use netcdf, only: nf90_put_att
-    use handle_err_m, only: handle_err
-
-    integer, intent(in) :: ncid, varid
-    character(len = *), intent(in) :: name
-    character(len = *), intent(in) :: values
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_put_att(ncid, varid, name, values)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_att_text " // trim(name), ncerr_not_opt, &
-            ncid, varid)
-    end if
-
-  end subroutine nf95_put_att_text
-
-  !************************************
-
-  subroutine nf95_put_att_one_FourByteInt(ncid, varid, name, values, ncerr)
-
-    use netcdf, only: nf90_put_att
-    use handle_err_m, only: handle_err
-    use typesizes, only: FourByteInt
-
-    integer, intent(in) :: ncid, varid
-    character(len = *), intent(in) :: name
-    integer(kind = FourByteInt), intent(in) :: values
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_put_att(ncid, varid, name, values)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_att_one_FourByteInt " // trim(name), &
-            ncerr_not_opt, ncid, varid)
-    end if
-
-  end subroutine nf95_put_att_one_FourByteInt
-
-  !************************************
-
-  subroutine nf95_put_att_one_FourByteReal(ncid, varid, name, values, ncerr)
-
-    use netcdf, only: nf90_put_att
-    use handle_err_m, only: handle_err
-    use typesizes, only: FourByteReal
-
-    integer, intent(in) :: ncid, varid
-    character(len = *), intent(in) :: name
-    real(kind = FourByteReal), intent(in) :: values
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_put_att(ncid, varid, name, values)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_att_one_FourByteReal " // trim(name), &
-            ncerr_not_opt, ncid, varid)
-    end if
-
-  end subroutine nf95_put_att_one_FourByteReal
-
-end module nf95_put_att_m
diff -uNrp NetCDF95/nf95_put_var.f90 NetCDF95-mods/nf95_put_var.f90
--- NetCDF95/nf95_put_var.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_put_var.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,389 +0,0 @@
-module nf95_put_var_m
-
-  use netcdf, only: nf90_put_var
-  use handle_err_m, only: handle_err
-  use check_start_count_m, only: check_start_count
-
-  implicit none
-
-  interface nf95_put_var
-     module procedure nf95_put_var_FourByteReal, nf95_put_var_FourByteInt, &
-          nf95_put_var_1D_FourByteReal, nf95_put_var_1D_FourByteInt, &
-          nf95_put_var_1D_EightByteReal, nf95_put_var_2D_FourByteReal, &
-          nf95_put_var_2D_FourByteInt, nf95_put_var_2D_EightByteReal, &
-          nf95_put_var_3D_FourByteReal, nf95_put_var_3D_EightByteReal, &
-          nf95_put_var_4D_FourByteReal, nf95_put_var_4D_EightByteReal
-  end interface
-
-  private
-  public nf95_put_var
-
-contains
-
-  subroutine nf95_put_var_FourByteReal(ncid, varid, values, start, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer, intent(in) :: ncid, varid
-    real(kind = FourByteReal), intent(in) :: values
-    integer, dimension(:), optional, intent(in) :: start
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_FourByteReal", ncid, varid, start, &
-         rank_values=0)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_FourByteReal", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_FourByteReal
-
-  !***********************
-
-  subroutine nf95_put_var_FourByteInt(ncid, varid, values, start, ncerr)
-
-    use typesizes, only: FourByteInt
-
-    integer, intent(in) :: ncid, varid
-    integer(kind = FourByteInt), intent(in) :: values
-    integer, dimension(:), optional, intent(in) :: start
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_FourByteInt", ncid, varid, start, &
-         rank_values=0)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_FourByteInt", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_FourByteInt
-
-  !***********************
-
-  subroutine nf95_put_var_1D_FourByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer,                         intent(in) :: ncid, varid
-    real(kind = FourByteReal), intent(in) :: values(:)
-    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_1D_FourByteReal", ncid, varid, &
-         start, count_nc, rank_values=1)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
-         stride, map)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_1D_FourByteReal", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_1D_FourByteReal
-
-  !***********************
-
-  subroutine nf95_put_var_1D_FourByteInt(ncid, varid, values, start, &
-       count_nc, stride, map, ncerr)
-
-    use typesizes, only: FourByteInt
-
-    integer,                         intent(in) :: ncid, varid
-    integer(kind = FourByteInt), intent(in) :: values(:)
-    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_1D_FourByteInt", ncid, varid, start, &
-         count_nc, rank_values=1)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
-         stride, map)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_1D_FourByteInt", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_1D_FourByteInt
-
-  !***********************
-
-  subroutine nf95_put_var_1D_EightByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, ncerr)
-
-    use typesizes, only: eightByteReal
-
-    integer,                         intent(in) :: ncid, varid
-    real (kind = EightByteReal),     intent(in) :: values(:)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_1D_EightByteReal", ncid, varid, &
-         start, count_nc, rank_values=1)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
-         stride, map)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_1D_eightByteReal", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_1D_EightByteReal
-
-  !***********************
-
-  subroutine nf95_put_var_2D_FourByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer,                         intent(in) :: ncid, varid
-    real (kind = FourByteReal), intent(in) :: values(:, :)
-    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_2D_FourByteReal", ncid, varid, &
-         start, count_nc, rank_values=2)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
-         stride, map)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_2D_FourByteReal", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_2D_FourByteReal
-
-  !***********************
-
-  subroutine nf95_put_var_2D_FourByteint(ncid, varid, values, start, &
-       count_nc, stride, map, ncerr)
-
-    use typesizes, only: FourByteInt
-
-    integer,                         intent(in) :: ncid, varid
-    integer(kind = FourByteInt), intent(in) :: values(:, :)
-    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_2D_FourByteInt", ncid, varid, &
-         start, count_nc, rank_values=2)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
-         stride, map)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_2D_FourByteInt", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_2D_FourByteint
-
-  !***********************
-
-  subroutine nf95_put_var_2D_EightByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, ncerr)
-
-    use typesizes, only: EightByteReal
-
-    integer,                         intent(in) :: ncid, varid
-    real (kind = EightByteReal), intent(in) :: values(:, :)
-    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_2D_EightByteReal", ncid, varid, &
-         start, count_nc, rank_values=2)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
-         stride, map)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_2D_EightByteReal", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_2D_EightByteReal
-
-  !***********************
-
-  subroutine nf95_put_var_3D_FourByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer,                         intent(in) :: ncid, varid
-    real (kind = FourByteReal), intent(in) :: values(:, :, :)
-    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_3D_FourByteReal", ncid, varid, &
-         start, count_nc, rank_values=3)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
-         stride, map)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_3D_FourByteReal", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_3D_FourByteReal
-
-  !***********************
-
-  subroutine nf95_put_var_3D_EightByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, ncerr)
-
-    use typesizes, only: eightByteReal
-
-    integer,                         intent(in) :: ncid, varid
-    real (kind = EightByteReal),     intent(in) :: values(:, :, :)
-    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_3D_EightByteReal", ncid, varid, &
-         start, count_nc, rank_values=3)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
-         stride, map)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_3D_eightByteReal", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_3D_EightByteReal
-
-  !***********************
-
-  subroutine nf95_put_var_4D_FourByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, ncerr)
-
-    use typesizes, only: FourByteReal
-
-    integer,                         intent(in) :: ncid, varid
-    real (kind = FourByteReal), intent(in) :: values(:, :, :, :)
-    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_4D_FourByteReal", ncid, varid, &
-         start, count_nc, rank_values=4)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
-         stride, map)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_4D_FourByteReal", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_4D_FourByteReal
-
-  !***********************
-
-  subroutine nf95_put_var_4D_EightByteReal(ncid, varid, values, start, &
-       count_nc, stride, map, ncerr)
-
-    use typesizes, only: EightByteReal
-
-    integer, intent(in):: ncid, varid
-    real(kind = EightByteReal), intent(in):: values(:, :, :, :)
-    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
-    integer, intent(out), optional:: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    call check_start_count("nf95_put_var_4D_EightByteReal", ncid, varid, &
-         start, count_nc, rank_values=4)
-
-    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
-         stride, map)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_put_var_4D_EightByteReal", ncerr_not_opt, ncid, &
-            varid)
-    end if
-
-  end subroutine nf95_put_var_4D_EightByteReal
-
-end module nf95_put_var_m
diff -uNrp NetCDF95/nf95_redef.f90 NetCDF95-mods/nf95_redef.f90
--- NetCDF95/nf95_redef.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_redef.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,29 +0,0 @@
-module nf95_redef_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_redef(ncid, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_redef
-
-    integer, intent( in) :: ncid
-    integer, intent(out), optional :: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_redef(ncid)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_redef", ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_redef
-
-end module nf95_redef_m
diff -uNrp NetCDF95/nf95_sync.f90 NetCDF95-mods/nf95_sync.f90
--- NetCDF95/nf95_sync.f90	2020-03-31 07:05:51.000000000 -0500
+++ NetCDF95-mods/nf95_sync.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,29 +0,0 @@
-module nf95_sync_m
-
-  implicit none
-
-contains
-
-  subroutine nf95_sync(ncid, ncerr)
-
-    use handle_err_m, only: handle_err
-    use netcdf, only: nf90_sync
-
-    integer, intent( in) :: ncid
-    integer, intent(out), optional :: ncerr
-
-    ! Variable local to the procedure:
-    integer ncerr_not_opt
-
-    !-------------------
-
-    ncerr_not_opt = nf90_sync(ncid)
-    if (present(ncerr)) then
-       ncerr = ncerr_not_opt
-    else
-       call handle_err("nf95_sync", ncerr_not_opt, ncid)
-    end if
-
-  end subroutine nf95_sync
-
-end module nf95_sync_m
diff -uNrp NetCDF95/src/check_start_count.f90 NetCDF95-mods/src/check_start_count.f90
--- NetCDF95/src/check_start_count.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/check_start_count.f90	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,81 @@
+module check_start_count_m
+
+  implicit none
+
+  private check_one_arg
+
+contains
+
+  subroutine check_start_count(name_calling, ncid, varid, start, count_nc, &
+       rank_values)
+
+    ! This procedure checks that:
+
+    ! - the size of start and count_nc equals the rank of the NetCDF variable;
+
+    ! - if count_nc is absent, the rank of values is lower than or
+    ! equal to the rank of the NetCDF variable.
+
+    use nf95_close_m, only: nf95_close
+    use nf95_inquire_variable_m, only: nf95_inquire_variable
+    use netcdf, only: nf90_noerr
+
+    character(len=*), intent(in):: name_calling ! name of calling procedure
+    integer, intent(in):: ncid, varid
+    integer, optional, intent(in):: start(:), count_nc(:)
+    integer, intent(in):: rank_values ! rank of argument "values"
+
+    ! Variables local to the procedure:
+    integer ncerr_not_opt, ndims
+
+    !-------------------
+
+    call nf95_inquire_variable(ncid, varid, ndims=ndims, ncerr=ncerr_not_opt)
+    if (ncerr_not_opt == nf90_noerr) then
+       call check_one_arg(name_calling, "start", ncid, varid, ndims, start)
+       call check_one_arg(name_calling, "count_nc", ncid, varid, ndims, &
+            count_nc)
+       if (.not. present(count_nc) .and. rank_values > ndims) then
+          print *, name_calling, ":"
+          print *, "varid = ", varid
+          print *, "Argument count_nc is absent and rank of argument values " &
+               // "is greater than rank of NetCDF variable"
+          print *, "rank of argument values: ", rank_values
+          print *, "rank of NetCDF variable: ", ndims
+          call nf95_close(ncid)
+          stop 1
+       end if
+    end if
+
+  end subroutine check_start_count
+
+  !**************************************************************
+
+  subroutine check_one_arg(name_calling, arg_name, ncid, varid, ndims, &
+       checked_arg)
+
+    use nf95_close_m, only: nf95_close
+
+    character(len=*), intent(in):: name_calling ! name of calling procedure
+    character(len=*), intent(in):: arg_name ! name of checked argument
+    integer, intent(in):: ncid, varid, ndims
+    integer, optional, intent(in):: checked_arg(:) ! start or count_nc
+
+    !-------------------
+
+    if (present(checked_arg)) then
+       if (size(checked_arg) /= ndims) then
+          print *, name_calling, ":"
+          print *, "varid = ", varid
+          print *, 'size of ' // arg_name // ' does not match rank of ' &
+               // 'NetCDF variable'
+          print *, 'size of ' // arg_name // " = ", size(checked_arg)
+          print *, "rank of NetCDF variable: ", ndims
+          call nf95_close(ncid)
+          stop 1
+       end if
+    end if
+
+  end subroutine check_one_arg
+
+end module check_start_count_m
diff -uNrp NetCDF95/src/find_coord.f90 NetCDF95-mods/src/find_coord.f90
--- NetCDF95/src/find_coord.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/find_coord.f90	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,112 @@
+module find_coord_m
+
+  implicit none
+
+contains
+
+  subroutine find_coord(ncid, name, dimid, varid, std_name)
+
+    ! This procedure returns the name, dimension id or variable id of
+    ! the NetCDF coordinate with standard name "std_name", if such a
+    ! coordinate exists. The standard name is only used to know what
+    ! to search, it is not used for the search itself. The search
+    ! itself is done via a string match on the attribute "units". So
+    ! the NetCDF variable one looks for does not need to have the
+    ! attribute "std_name".
+
+    use netcdf, only: NF90_MAX_NAME, NF90_NOERR
+    use nf95_get_att_m, only: nf95_get_att
+    use nf95_inq_varid_m, only: nf95_inq_varid
+    use nf95_inquire_dimension_m, only: nf95_inquire_dimension
+    use nf95_inquire_m, only: nf95_inquire
+    use nf95_inquire_variable_m, only: nf95_inquire_variable
+
+    integer, intent(in):: ncid
+
+    character(len=*), intent(out), optional:: name ! blanks if not found
+    ! The actual character argument should normally have the length
+    ! "NF90_MAX_NAME".
+
+    integer, intent(out), optional:: dimid ! 0 if not found
+    integer, intent(out), optional:: varid ! 0 if not found
+
+    character(len=*), intent(in):: std_name
+    ! standard name : "plev", "latitude", "longitude" or "time"
+
+    ! Variables local to the procedure:
+
+    character(len=13), allocatable:: units(:)
+    logical exact ! "units" must be matched exactly
+
+    integer ncerr, nDimensions, dimid_local, varid_local
+    character(len=NF90_MAX_NAME) name_local
+    integer, allocatable:: dimids(:)
+    character(len=80) values
+    logical found
+
+    !----------------------------------------------
+
+    select case (std_name)
+    case("longitude")
+       allocate(units(1))
+       units(1)="degrees_east"
+       exact=.true.
+    case("latitude")
+       allocate(units(1))
+       units(1)="degrees_north"
+       exact=.true.
+    case("time")
+       allocate(units(1))
+       units(1)=" since"
+       exact=.false.
+    case("plev")
+       allocate(units(4))
+       units = ["Pa           ", "hPa          ", "millibar     ", &
+            "mbar         "]
+       exact = .true.
+    case default
+       print *, "find_coord: bad value of std_name"
+       print *, "std_name = ", std_name
+       stop 1
+    end select
+
+    call nf95_inquire(ncid, nDimensions)
+    dimid_local = 0
+    found = .false.
+
+    ! Loop on dimensions:
+    do while (.not. found .and. dimid_local < nDimensions)
+       dimid_local = dimid_local + 1
+       call nf95_inquire_dimension(ncid, dimid_local, name_local)
+       call nf95_inq_varid(ncid, name_local, varid_local, ncerr)
+       if (ncerr == NF90_NOERR) then
+          call nf95_inquire_variable(ncid, varid_local, dimids=dimids)
+          if (size(dimids) == 1) then
+             if (dimids(1) == dimid_local) then
+                ! We have found a coordinate
+                call nf95_get_att(ncid, varid_local, "units", values, ncerr)
+                if (ncerr == NF90_NOERR)then
+                   if (exact) then
+                      found = any(values == units)
+                   else
+                      found = index(values, trim(units(1))) /= 0
+                   end if
+                end if
+             end if
+          end if
+       end if
+    end do
+
+    if (found) then
+       if (present(name)) name = name_local
+       if (present(dimid)) dimid = dimid_local
+       if (present(varid)) varid = varid_local
+    else
+       if (present(name)) name = ""
+       if (present(dimid)) dimid = 0
+       if (present(varid)) varid = 0
+    end if
+
+  end subroutine find_coord
+
+end module find_coord_m
diff -uNrp NetCDF95/src/handle_err.f90 NetCDF95-mods/src/handle_err.f90
--- NetCDF95/src/handle_err.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/handle_err.f90	2020-12-12 23:33:03.261712004 -0600
@@ -0,0 +1,45 @@
+module handle_err_m
+
+  implicit none
+
+contains
+
+  subroutine handle_err(message, ncerr, ncid, varid)
+
+    use netcdf, only: nf90_strerror, nf90_noerr, nf90_close
+
+    character(len=*), intent(in):: message
+    ! (should include name of calling procedure)
+
+    integer, intent(in):: ncerr
+
+    integer, intent(in), optional :: ncid
+    ! (Provide this argument if you want "handle_err" to try to close
+    ! the file.)
+
+    integer, intent(in), optional :: varid
+
+    ! Variable local to the procedure:
+    integer ncerr_close
+
+    !-------------------
+
+    if (ncerr /= nf90_noerr) then
+       print *, message, ":"
+       if (present(varid)) print *, "varid = ", varid
+       print *, trim(nf90_strerror(ncerr))
+       if (present(ncid)) then
+          ! Try to close, to leave the file in a consistent state:
+          ncerr_close = nf90_close(ncid)
+          ! (do not call "nf95_close", we do not want to recurse)
+          if (ncerr_close /= nf90_noerr) then
+             print *, "nf90_close:"
+             print *, trim(nf90_strerror(ncerr_close))
+          end if
+       end if
+       stop 1
+    end if
+
+  end subroutine handle_err
+
+end module handle_err_m
diff -uNrp NetCDF95/src/netcdf95.f90 NetCDF95-mods/src/netcdf95.f90
--- NetCDF95/src/netcdf95.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/netcdf95.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,29 @@
+module netcdf95
+
+  ! Author: Lionel GUEZ
+
+  use find_coord_m
+  use handle_err_m
+  use nf95_close_m
+  use nf95_copy_att_m
+  use nf95_create_m
+  use nf95_def_dim_m
+  use nf95_def_var_m
+  use nf95_enddef_m
+  use nf95_get_att_m
+  use nf95_get_missing_m
+  use nf95_get_var_m
+  use nf95_gw_var_m
+  use nf95_inq_dimid_m
+  use nf95_inq_varid_m
+  use nf95_inquire_attribute_m
+  use nf95_inquire_dimension_m
+  use nf95_inquire_m
+  use nf95_inquire_variable_m
+  use nf95_open_m
+  use nf95_put_att_m
+  use nf95_put_var_m
+  use nf95_redef_m
+  use nf95_sync_m
+
+end module netcdf95
diff -uNrp NetCDF95/src/nf95_close.f90 NetCDF95-mods/src/nf95_close.f90
--- NetCDF95/src/nf95_close.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_close.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,29 @@
+module nf95_close_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_close(ncid, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_close
+
+    integer, intent( in) :: ncid
+    integer, intent(out), optional :: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_close(ncid)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_close", ncerr_not_opt)
+    end if
+
+  end subroutine nf95_close
+
+end module nf95_close_m
diff -uNrp NetCDF95/src/nf95_copy_att.f90 NetCDF95-mods/src/nf95_copy_att.f90
--- NetCDF95/src/nf95_copy_att.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_copy_att.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,32 @@
+module nf95_copy_att_m
+
+  implicit none
+
+contains
+
+
+  subroutine nf95_copy_att(ncid_in, varid_in, name, ncid_out, varid_out, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_copy_att
+
+    integer, intent( in):: ncid_in,  varid_in
+    character(len=*), intent( in):: name
+    integer, intent( in):: ncid_out, varid_out
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_copy_att(ncid_in, varid_in, name, ncid_out, varid_out)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_copy_att " // name, ncerr_not_opt, ncid_out)
+    end if
+
+  end subroutine nf95_copy_att
+
+end module nf95_copy_att_m
diff -uNrp NetCDF95/src/nf95_create.f90 NetCDF95-mods/src/nf95_create.f90
--- NetCDF95/src/nf95_create.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_create.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,33 @@
+module nf95_create_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_create(path, cmode, ncid, initialsize, chunksize, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_create
+
+    character (len = *), intent(in   ) :: path
+    integer,             intent(in   ) :: cmode
+    integer,             intent(  out) :: ncid
+    integer, optional,   intent(in   ) :: initialsize
+    integer, optional,   intent(inout) :: chunksize
+    integer, intent(out), optional :: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_create(path, cmode, ncid, initialsize, chunksize)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_create " // path, ncerr_not_opt)
+    end if
+
+  end subroutine nf95_create
+
+end module nf95_create_m
diff -uNrp NetCDF95/src/nf95_def_dim.f90 NetCDF95-mods/src/nf95_def_dim.f90
--- NetCDF95/src/nf95_def_dim.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_def_dim.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,32 @@
+module nf95_def_dim_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_def_dim(ncid, name, nclen, dimid, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_def_dim
+
+    integer,             intent( in) :: ncid
+    character (len = *), intent( in) :: name
+    integer,             intent( in) :: nclen
+    integer,             intent(out) :: dimid
+    integer, intent(out), optional :: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_def_dim(ncid, name, nclen, dimid)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_def_dim " // name, ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_def_dim
+
+end module nf95_def_dim_m
diff -uNrp NetCDF95/src/nf95_def_var.f90 NetCDF95-mods/src/nf95_def_var.f90
--- NetCDF95/src/nf95_def_var.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_def_var.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,104 @@
+module nf95_def_var_m
+
+  ! The generic procedure name "nf90_def_var" applies to
+  ! "nf90_def_var_Scalar" but we cannot apply the generic procedure name
+  ! "nf95_def_var" to "nf95_def_var_scalar" because of the additional
+  ! optional argument.
+  ! "nf95_def_var_scalar" cannot be distinguished from "nf95_def_var_oneDim".
+
+  implicit none
+
+  interface nf95_def_var
+    module procedure nf95_def_var_oneDim, nf95_def_var_ManyDims
+  end interface
+
+  private
+  public nf95_def_var, nf95_def_var_scalar
+
+contains
+
+  subroutine nf95_def_var_scalar(ncid, name, xtype, varid, ncerr)
+
+    use netcdf, only: nf90_def_var
+    use handle_err_m, only: handle_err
+
+    integer,               intent( in) :: ncid
+    character (len = *),   intent( in) :: name
+    integer,               intent( in) :: xtype
+    integer,               intent(out) :: varid
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_def_var(ncid, name, xtype, varid)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_def_var_scalar, name =  " // name, &
+            ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_def_var_scalar
+
+  !***********************
+
+  subroutine nf95_def_var_oneDim(ncid, name, xtype, dimids, varid, ncerr)
+
+    use netcdf, only: nf90_def_var
+    use handle_err_m, only: handle_err
+
+    integer,               intent( in) :: ncid
+    character (len = *),   intent( in) :: name
+    integer,               intent( in) :: xtype
+    integer,               intent( in) :: dimids
+    integer,               intent(out) :: varid
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_def_var(ncid, name, xtype, dimids, varid)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_def_var_oneDim, name =  " // name, &
+            ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_def_var_oneDim
+
+  !***********************
+
+  subroutine nf95_def_var_ManyDims(ncid, name, xtype, dimids, varid, ncerr)
+
+    use netcdf, only: nf90_def_var
+    use handle_err_m, only: handle_err
+
+    integer,               intent( in) :: ncid
+    character (len = *),   intent( in) :: name
+    integer,               intent( in) :: xtype
+    integer, dimension(:), intent( in) :: dimids
+    integer,               intent(out) :: varid
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_def_var(ncid, name, xtype, dimids, varid)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_def_var_ManyDims, name = " // name, &
+            ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_def_var_ManyDims
+
+end module nf95_def_var_m
diff -uNrp NetCDF95/src/nf95_enddef.f90 NetCDF95-mods/src/nf95_enddef.f90
--- NetCDF95/src/nf95_enddef.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_enddef.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,30 @@
+module nf95_enddef_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_enddef(ncid, h_minfree, v_align, v_minfree, r_align, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_enddef
+
+    integer,           intent( in) :: ncid
+    integer, optional, intent( in) :: h_minfree, v_align, v_minfree, r_align
+    integer, intent(out), optional :: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_enddef(ncid, h_minfree, v_align, v_minfree, r_align)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_enddef", ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_enddef
+
+end module nf95_enddef_m
diff -uNrp NetCDF95/src/nf95_get_att.f90 NetCDF95-mods/src/nf95_get_att.f90
--- NetCDF95/src/nf95_get_att.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_get_att.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,189 @@
+module nf95_get_att_m
+
+  use handle_err_m, only: handle_err
+  use netcdf, only: nf90_get_att, nf90_noerr
+  use nf95_inquire_attribute_m, only: nf95_inquire_attribute
+
+  implicit none
+
+  interface nf95_get_att
+     module procedure nf95_get_att_text, nf95_get_att_one_FourByteInt, &
+          nf95_get_att_one_FourByteReal, nf95_get_att_one_eightByteReal
+
+     ! The difference between the specific procedures is the type of
+     ! argument "values".
+  end interface nf95_get_att
+
+  private
+  public nf95_get_att
+
+contains
+
+  subroutine nf95_get_att_text(ncid, varid, name, values, ncerr)
+
+    integer, intent(in):: ncid, varid
+    character(len = *), intent(in):: name
+    character(len = *), intent(out):: values
+    integer, intent(out), optional:: ncerr
+
+    ! Variables local to the procedure:
+    integer ncerr_not_opt
+    integer att_len
+
+    !-------------------
+
+    ! Check that the length of "values" is large enough:
+    call nf95_inquire_attribute(ncid, varid, name, nclen=att_len, &
+         ncerr=ncerr_not_opt)
+    if (ncerr_not_opt == nf90_noerr) then
+       if (len(values) < att_len) then
+          print *, "nf95_get_att_text"
+          print *, "varid = ", varid
+          print *, "attribute name: ", name
+          print *, 'length of "values" is not large enough'
+          print *, "len(values) = ", len(values)
+          print *, "number of characters in attribute: ", att_len
+          stop 1
+       end if
+    end if
+
+    values = "" ! useless in NetCDF version 3.6.2 or better
+    ncerr_not_opt = nf90_get_att(ncid, varid, name, values)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_get_att_text " // trim(name), ncerr_not_opt, &
+            ncid, varid)
+    end if
+
+    if (att_len >= 1 .and. ncerr_not_opt == nf90_noerr) then
+       ! Remove null terminator, if any:
+       if (iachar(values(att_len:att_len)) == 0) values(att_len:att_len) = " "
+    end if
+
+  end subroutine nf95_get_att_text
+
+  !***********************
+
+  subroutine nf95_get_att_one_FourByteInt(ncid, varid, name, values, ncerr)
+
+    use typesizes, only: FourByteInt
+
+    integer, intent(in):: ncid, varid
+    character(len = *), intent(in):: name
+    integer (kind = FourByteInt), intent(out):: values
+    integer, intent(out), optional:: ncerr
+
+    ! Variables local to the procedure:
+    integer ncerr_not_opt
+    integer att_len
+
+    !-------------------
+
+    ! Check that the attribute contains a single value:
+    call nf95_inquire_attribute(ncid, varid, name, nclen=att_len, &
+         ncerr=ncerr_not_opt)
+    if (ncerr_not_opt == nf90_noerr) then
+       if (att_len /= 1) then
+          print *, "nf95_get_att_one_FourByteInt"
+          print *, "varid = ", varid
+          print *, "attribute name: ", name
+          print *, 'the attribute does not contain a single value'
+          print *, "number of values in attribute: ", att_len
+          stop 1
+       end if
+    end if
+
+    ncerr_not_opt = nf90_get_att(ncid, varid, name, values)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_get_att_one_FourByteInt " // trim(name), &
+            ncerr_not_opt, ncid, varid)
+    end if
+
+  end subroutine nf95_get_att_one_FourByteInt
+
+  !***********************
+
+  subroutine nf95_get_att_one_FourByteReal(ncid, varid, name, values, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer, intent(in):: ncid, varid
+    character(len = *), intent(in):: name
+    real (kind = FourByteReal), intent(out):: values
+    integer, intent(out), optional:: ncerr
+
+    ! Variables local to the procedure:
+    integer ncerr_not_opt
+    integer att_len
+
+    !-------------------
+
+    ! Check that the attribute contains a single value:
+    call nf95_inquire_attribute(ncid, varid, name, nclen=att_len, &
+         ncerr=ncerr_not_opt)
+    if (ncerr_not_opt == nf90_noerr) then
+       if (att_len /= 1) then
+          print *, "nf95_get_att_one_Fourbytereal"
+          print *, "varid = ", varid
+          print *, "attribute name: ", name
+          print *, 'the attribute does not contain a single value'
+          print *, "number of values in attribute: ", att_len
+          stop 1
+       end if
+    end if
+
+    ncerr_not_opt = nf90_get_att(ncid, varid, name, values)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_get_att_one_Fourbytereal " // trim(name), &
+            ncerr_not_opt, ncid, varid)
+    end if
+
+  end subroutine nf95_get_att_one_Fourbytereal
+
+  !***********************
+
+  subroutine nf95_get_att_one_EightByteReal(ncid, varid, name, values, ncerr)
+
+    use typesizes, only: EightByteReal
+
+    integer, intent(in):: ncid, varid
+    character(len = *), intent(in):: name
+    real (kind = EightByteReal), intent(out):: values
+    integer, intent(out), optional:: ncerr
+
+    ! Variables local to the procedure:
+    integer ncerr_not_opt
+    integer att_len
+
+    !-------------------
+
+    ! Check that the attribute contains a single value:
+    call nf95_inquire_attribute(ncid, varid, name, nclen=att_len, &
+         ncerr=ncerr_not_opt)
+    if (ncerr_not_opt == nf90_noerr) then
+       if (att_len /= 1) then
+          print *, "nf95_get_att_one_Eightbytereal"
+          print *, "varid = ", varid
+          print *, "attribute name: ", name
+          print *, 'the attribute does not contain a single value'
+          print *, "number of values in attribute: ", att_len
+          stop 1
+       end if
+    end if
+
+    ncerr_not_opt = nf90_get_att(ncid, varid, name, values)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_get_att_one_Eightbytereal " // trim(name), &
+            ncerr_not_opt, ncid, varid)
+    end if
+
+  end subroutine nf95_get_att_one_Eightbytereal
+
+end module nf95_get_att_m
diff -uNrp NetCDF95/src/nf95_get_missing.f90 NetCDF95-mods/src/nf95_get_missing.f90
--- NetCDF95/src/nf95_get_missing.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_get_missing.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,91 @@
+module nf95_get_missing_m
+
+  use netcdf, only: nf90_noerr
+  use nf95_get_att_m, only: nf95_get_att
+
+  implicit none
+
+  interface nf95_get_missing
+     module procedure nf95_get_missing_real, nf95_get_missing_dble, &
+          nf95_get_missing_int
+  end interface nf95_get_missing
+
+  private
+  public nf95_get_missing
+
+contains
+
+  subroutine nf95_get_missing_real(ncid, varid, missing)
+
+    use netcdf, only: NF90_FILL_REAL
+
+    integer, intent(in)::  ncid, varid
+    real, intent(out):: missing ! missing or fill value
+
+    ! Local:
+    integer ncerr
+
+    !-------------------------------------------------------------------
+
+    call nf95_get_att(ncid, varid, name = "missing_value", values = missing, &
+         ncerr = ncerr)
+
+    if (ncerr /= nf90_noerr) then
+       call nf95_get_att(ncid, varid, name = "_FillValue", values = missing, &
+            ncerr = ncerr)
+       if (ncerr /= nf90_noerr) missing = NF90_FILL_REAL
+    end if
+
+  end subroutine nf95_get_missing_real
+
+  !**************************************************************************
+
+  subroutine nf95_get_missing_dble(ncid, varid, missing)
+
+    use netcdf, only: NF90_FILL_double
+
+    integer, intent(in)::  ncid, varid
+    double precision, intent(out):: missing ! missing or fill value
+
+    ! Local:
+    integer ncerr
+
+    !-------------------------------------------------------------------
+
+    call nf95_get_att(ncid, varid, name = "missing_value", values = missing, &
+         ncerr = ncerr)
+
+    if (ncerr /= nf90_noerr) then
+       call nf95_get_att(ncid, varid, name = "_FillValue", values = missing, &
+            ncerr = ncerr)
+       if (ncerr /= nf90_noerr) missing = NF90_FILL_double
+    end if
+
+  end subroutine nf95_get_missing_dble
+
+  !**************************************************************************
+
+  subroutine nf95_get_missing_int(ncid, varid, missing)
+
+    use netcdf, only: NF90_FILL_INT
+
+    integer, intent(in)::  ncid, varid
+    integer, intent(out):: missing ! missing or fill value
+
+    ! Local:
+    integer ncerr
+
+    !-------------------------------------------------------------------
+
+    call nf95_get_att(ncid, varid, name = "missing_value", values = missing, &
+         ncerr = ncerr)
+
+    if (ncerr /= nf90_noerr) then
+       call nf95_get_att(ncid, varid, name = "_FillValue", values = missing, &
+            ncerr = ncerr)
+       if (ncerr /= nf90_noerr) missing = NF90_FILL_INT
+    end if
+
+  end subroutine nf95_get_missing_int
+
+end module nf95_get_missing_m
diff -uNrp NetCDF95/src/nf95_get_var.f90 NetCDF95-mods/src/nf95_get_var.f90
--- NetCDF95/src/nf95_get_var.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_get_var.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,398 @@
+module nf95_get_var_m
+
+  use netcdf, only: nf90_get_var, NF90_NOERR
+  
+  use handle_err_m, only: handle_err
+  use check_start_count_m, only: check_start_count
+  use nf95_get_missing_m, only: nf95_get_missing
+
+  implicit none
+
+  interface nf95_get_var
+     module procedure nf95_get_var_FourByteReal, nf95_get_var_FourByteInt, &
+          nf95_get_var_1D_FourByteReal, nf95_get_var_1D_FourByteInt, &
+          nf95_get_var_1D_EightByteReal, nf95_get_var_2D_FourByteReal, &
+          nf95_get_var_2D_EightByteReal, nf95_get_var_2D_FourByteInt, &
+          nf95_get_var_3D_FourByteInt, nf95_get_var_3D_FourByteReal, &
+          nf95_get_var_3D_EightByteReal, nf95_get_var_4D_FourByteReal, &
+          nf95_get_var_4D_EightByteReal, nf95_get_var_5D_FourByteReal, &
+          nf95_get_var_5D_EightByteReal
+  end interface
+
+  private
+  public nf95_get_var
+
+  integer ncerr_not_opt
+
+contains
+
+  subroutine nf95_get_var_FourByteReal(ncid, varid, values, start, &
+       new_missing, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer, intent(in):: ncid, varid
+    real(kind = FourByteReal), intent(out):: values
+    integer, dimension(:), optional, intent(in):: start
+    real(kind = FourByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = "nf95_get_var_FourByteReal"
+    real(kind = FourByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_scalar.h"
+
+  end subroutine nf95_get_var_FourByteReal
+
+  !***********************
+
+  subroutine nf95_get_var_FourByteInt(ncid, varid, values, start, &
+       new_missing, ncerr)
+
+    use typesizes, only: FourByteInt
+
+    integer, intent(in):: ncid, varid
+    integer(kind = FourByteInt), intent(out):: values
+    integer, dimension(:), optional, intent(in):: start
+    integer(kind = FourByteInt), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = "nf95_get_var_FourByteInt"
+    integer(kind = FourByteInt) missing
+    
+    !-------------------
+
+    include "nf95_get_var_scalar.h"
+
+  end subroutine nf95_get_var_FourByteInt
+
+  !***********************
+
+  subroutine nf95_get_var_1D_FourByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer,                         intent(in):: ncid, varid
+    real(kind = FourByteReal), intent(out):: values(:)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    real(kind = FourByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_1D_FourByteReal"
+    integer, parameter:: rank_values = 1
+    real(kind = FourByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_1D_FourByteReal
+
+  !***********************
+
+  subroutine nf95_get_var_1D_FourByteInt(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: FourByteInt
+
+    integer,                         intent(in):: ncid, varid
+    integer(kind = FourByteInt), intent(out):: values(:)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    integer(kind = FourByteInt), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_1D_FourByteInt"
+    integer, parameter:: rank_values = 1
+    integer(kind = FourByteInt) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_1D_FourByteInt
+
+  !***********************
+
+  subroutine nf95_get_var_1D_EightByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: eightByteReal
+
+    integer,                         intent(in):: ncid, varid
+    real(kind = EightByteReal),     intent(out):: values(:)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    real(kind = EightByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_1D_EightByteReal"
+    integer, parameter:: rank_values = 1
+    real(kind = EightByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_1D_EightByteReal
+
+  !***********************
+
+  subroutine nf95_get_var_2D_FourByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer,                         intent(in):: ncid, varid
+    real(kind = FourByteReal), intent(out):: values(:, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    real(kind = FourByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_2D_FourByteReal"
+    integer, parameter:: rank_values = 2
+    real(kind = FourByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_2D_FourByteReal
+
+  !***********************
+
+  subroutine nf95_get_var_2D_EightByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: EightByteReal
+
+    integer,                         intent(in):: ncid, varid
+    real(kind = EightByteReal), intent(out):: values(:, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    real(kind = EightByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_2D_EightByteReal"
+    integer, parameter:: rank_values = 2
+    real(kind = EightByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_2D_EightByteReal
+
+  !***********************
+
+  subroutine nf95_get_var_2D_FourByteInt(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: FourByteInt
+
+    integer, intent(in):: ncid, varid
+    integer(kind = FourByteInt), intent(out):: values(:, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    integer(kind = FourByteInt), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_2D_FourByteInt"
+    integer, parameter:: rank_values = 2
+    integer(kind = FourByteInt) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_2D_FourByteInt
+
+  !***********************
+
+  subroutine nf95_get_var_3D_FourByteInt(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: FourByteInt
+
+    integer, intent(in):: ncid, varid
+    integer(kind = FourByteInt), intent(out):: values(:, :, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    integer(kind = FourByteInt), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_3D_FourByteInt"
+    integer, parameter:: rank_values = 3
+    integer(kind = FourByteInt) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_3D_FourByteInt
+
+  !***********************
+
+  subroutine nf95_get_var_3D_FourByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer,                         intent(in):: ncid, varid
+    real(kind = FourByteReal), intent(out):: values(:, :, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    real(kind = FourByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_3D_FourByteReal"
+    integer, parameter:: rank_values = 3
+    real(kind = FourByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_3D_FourByteReal
+
+  !***********************
+
+  subroutine nf95_get_var_3D_EightByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: eightByteReal
+
+    integer,                         intent(in):: ncid, varid
+    real(kind = EightByteReal),     intent(out):: values(:, :, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    real(kind = EightByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_3D_EightByteReal"
+    integer, parameter:: rank_values = 3
+    real(kind = EightByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_3D_EightByteReal
+
+  !***********************
+
+  subroutine nf95_get_var_4D_FourByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer,                         intent(in):: ncid, varid
+    real(kind = FourByteReal), intent(out):: values(:, :, :, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    real(kind = FourByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_4D_FourByteReal"
+    integer, parameter:: rank_values = 4
+    real(kind = FourByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_4D_FourByteReal
+
+  !***********************
+
+  subroutine nf95_get_var_4D_EightByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: EightByteReal
+
+    integer, intent(in):: ncid, varid
+    real(kind = EightByteReal), intent(out):: values(:, :, :, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    real(kind = EightByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_4D_EightByteReal"
+    integer, parameter:: rank_values = 4
+    real(kind = EightByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_4D_EightByteReal
+
+  !***********************
+
+  subroutine nf95_get_var_5D_FourByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer, intent(in):: ncid, varid
+    real(kind = FourByteReal), intent(out):: values(:, :, :, :, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    real(kind = FourByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_5D_FourByteReal"
+    integer, parameter:: rank_values = 5
+    real(kind = FourByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_5D_FourByteReal
+
+  !***********************
+
+  subroutine nf95_get_var_5D_EightByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, new_missing, ncerr)
+
+    use typesizes, only: EightByteReal
+
+    integer, intent(in):: ncid, varid
+    real(kind = EightByteReal), intent(out):: values(:, :, :, :, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    real(kind = EightByteReal), optional, intent(in):: new_missing
+    integer, intent(out), optional:: ncerr
+
+    ! Local:
+    character(len=*), parameter:: procedure_name = &
+         "nf95_get_var_5D_EightByteReal"
+    integer, parameter:: rank_values = 5
+    real(kind = EightByteReal) missing
+
+    !-------------------
+
+    include "nf95_get_var_array.h"
+
+  end subroutine nf95_get_var_5D_EightByteReal
+
+end module nf95_get_var_m
diff -uNrp NetCDF95/src/nf95_get_var_array.h NetCDF95-mods/src/nf95_get_var_array.h
--- NetCDF95/src/nf95_get_var_array.h	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_get_var_array.h	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,20 @@
+  ! -*- mode: f90; -*-
+  
+  ! Body of specific procedures of generic interface "nf95_get_var",
+  ! with array argument "values".
+  
+  call check_start_count(procedure_name, ncid, varid, start, count_nc, &
+       rank_values)
+  ncerr_not_opt = nf90_get_var(ncid, varid, values, start, count_nc, stride, &
+       map)
+
+  if (present(ncerr)) then
+     ncerr = ncerr_not_opt
+  else
+     call handle_err(procedure_name, ncerr_not_opt, ncid, varid)
+  end if
+
+  if (ncerr_not_opt == NF90_NOERR .and. present(new_missing)) then
+     call nf95_get_missing(ncid, varid, missing)
+     where (values == missing) values = new_missing
+  end if
diff -uNrp NetCDF95/src/nf95_get_var_scalar.h NetCDF95-mods/src/nf95_get_var_scalar.h
--- NetCDF95/src/nf95_get_var_scalar.h	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_get_var_scalar.h	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,18 @@
+  ! -*- mode: f90; -*-
+  
+  ! Body of specific procedures of generic interface "nf95_get_var",
+  ! with scalar argument "values".
+  
+  call check_start_count(procedure_name, ncid, varid, start, rank_values = 0)
+  ncerr_not_opt = nf90_get_var(ncid, varid, values, start)
+
+  if (present(ncerr)) then
+     ncerr = ncerr_not_opt
+  else
+     call handle_err(procedure_name, ncerr_not_opt, ncid, varid)
+  end if
+
+  if (ncerr_not_opt == NF90_NOERR .and. present(new_missing)) then
+     call nf95_get_missing(ncid, varid, missing)
+     if (values == missing) values = new_missing
+  end if
diff -uNrp NetCDF95/src/nf95_gw_var.f90 NetCDF95-mods/src/nf95_gw_var.f90
--- NetCDF95/src/nf95_gw_var.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_gw_var.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,429 @@
+module nf95_gw_var_m
+
+  use nf95_get_var_m, only: NF95_GET_VAR
+  use nf95_inquire_variable_m, only: nf95_inquire_variable
+  use nf95_inquire_dimension_m, only: nf95_inquire_dimension
+
+  implicit none
+
+  interface nf95_gw_var
+     ! "nf95_gw_var" stands for "NetCDF 1995 get whole variable".
+     ! These procedures read a whole NetCDF variable (coordinate or
+     ! primary) into an array.
+     ! The difference between the procedures is the rank and type of
+     ! argument "values".
+     ! The procedures do not check the type of the NetCDF variable.
+
+     module procedure nf95_gw_var_real_1d, nf95_gw_var_real_2d, &
+          nf95_gw_var_real_3d, nf95_gw_var_real_4d, nf95_gw_var_real_5d, &
+          nf95_gw_var_dble_1d, nf95_gw_var_dble_2d, nf95_gw_var_dble_3d, &
+          nf95_gw_var_dble_4d, nf95_gw_var_int_1d, nf95_gw_var_int_2d, &
+          nf95_gw_var_int_3d
+  end interface
+
+  private
+  public nf95_gw_var
+
+contains
+
+  subroutine nf95_gw_var_real_1d(ncid, varid, values)
+
+    ! Real type, the array has rank 1.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    real, allocatable, intent(out):: values(:)
+
+    ! Variables local to the procedure:
+    integer nclen
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 1) then
+       print *, "nf95_gw_var_real_1d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 1"
+       stop 1
+    end if
+
+    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen)
+
+    allocate(values(nclen))
+    if (nclen /= 0) call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_real_1d
+
+  !************************************
+
+  subroutine nf95_gw_var_real_2d(ncid, varid, values)
+
+    ! Real type, the array has rank 2.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    real, allocatable, intent(out):: values(:, :)
+
+    ! Variables local to the procedure:
+    integer nclen1, nclen2
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 2) then
+       print *, "nf95_gw_var_real_2d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 2"
+       stop 1
+    end if
+
+    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
+    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
+
+    allocate(values(nclen1, nclen2))
+    if (nclen1 /= 0 .and. nclen2 /= 0) call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_real_2d
+
+  !************************************
+
+  subroutine nf95_gw_var_real_3d(ncid, varid, values)
+
+    ! Real type, the array has rank 3.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    real, allocatable, intent(out):: values(:, :, :)
+
+    ! Variables local to the procedure:
+    integer nclen1, nclen2, nclen3
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 3) then
+       print *, "nf95_gw_var_real_3d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 3"
+       stop 1
+    end if
+
+    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
+    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
+    call nf95_inquire_dimension(ncid, dimids(3), nclen=nclen3)
+
+    allocate(values(nclen1, nclen2, nclen3))
+    if (nclen1 /= 0 .and. nclen2 /= 0 .and. nclen3 /= 0) &
+         call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_real_3d
+
+  !************************************
+
+  subroutine nf95_gw_var_real_4d(ncid, varid, values)
+
+    ! Real type, the array has rank 4.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    real, allocatable, intent(out):: values(:, :, :, :)
+
+    ! Variables local to the procedure:
+    integer len_dim(4), i
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 4) then
+       print *, "nf95_gw_var_real_4d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 4"
+       stop 1
+    end if
+
+    do i = 1, 4
+       call nf95_inquire_dimension(ncid, dimids(i), nclen=len_dim(i))
+    end do
+
+    allocate(values(len_dim(1), len_dim(2), len_dim(3), len_dim(4)))
+    if (all(len_dim /= 0)) call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_real_4d
+
+  !************************************
+
+  subroutine nf95_gw_var_real_5d(ncid, varid, values)
+
+    ! Real type, the array has rank 5.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    real, allocatable, intent(out):: values(:, :, :, :, :)
+
+    ! Variables local to the procedure:
+    integer len_dim(5), i
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 5) then
+       print *, "nf95_gw_var_real_5d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 5"
+       stop 1
+    end if
+
+    do i = 1, 5
+       call nf95_inquire_dimension(ncid, dimids(i), nclen=len_dim(i))
+    end do
+
+    allocate(values(len_dim(1), len_dim(2), len_dim(3), len_dim(4), len_dim(5)))
+    if (all(len_dim /= 0)) call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_real_5d
+
+  !************************************
+
+  subroutine nf95_gw_var_dble_1d(ncid, varid, values)
+
+    ! Double precision, the array has rank 1.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    double precision, allocatable, intent(out):: values(:)
+
+    ! Variables local to the procedure:
+    integer nclen
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 1) then
+       print *, "nf95_gw_var_dble_1d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 1"
+        stop 1
+    end if
+
+    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen)
+
+    allocate(values(nclen))
+    if (nclen /= 0) call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_dble_1d
+
+  !************************************
+
+  subroutine nf95_gw_var_dble_2d(ncid, varid, values)
+
+    ! Double precision, the array has rank 2.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    double precision, allocatable, intent(out):: values(:, :)
+
+    ! Variables local to the procedure:
+    integer nclen1, nclen2
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 2) then
+       print *, "nf95_gw_var_dble_2d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 2"
+       stop 1
+    end if
+
+    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
+    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
+
+    allocate(values(nclen1, nclen2))
+    if (nclen1 /= 0 .and. nclen2 /= 0) call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_dble_2d
+
+  !************************************
+
+  subroutine nf95_gw_var_dble_3d(ncid, varid, values)
+
+    ! Double precision, the array has rank 3.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    double precision, allocatable, intent(out):: values(:, :, :)
+
+    ! Variables local to the procedure:
+    integer nclen1, nclen2, nclen3
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 3) then
+       print *, "nf95_gw_var_dble_3d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 3"
+       stop 1
+    end if
+
+    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
+    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
+    call nf95_inquire_dimension(ncid, dimids(3), nclen=nclen3)
+
+    allocate(values(nclen1, nclen2, nclen3))
+    if (nclen1 /= 0 .and. nclen2 /= 0 .and. nclen3 /= 0) &
+         call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_dble_3d
+
+  !************************************
+
+  subroutine nf95_gw_var_dble_4d(ncid, varid, values)
+
+    ! Double precision, the array has rank 4.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    double precision, allocatable, intent(out):: values(:, :, :, :)
+
+    ! Variables local to the procedure:
+    integer len_dim(4), i
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 4) then
+       print *, "nf95_gw_var_dble_4d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 4"
+       stop 1
+    end if
+
+    do i = 1, 4
+       call nf95_inquire_dimension(ncid, dimids(i), nclen=len_dim(i))
+    end do
+
+    allocate(values(len_dim(1), len_dim(2), len_dim(3), len_dim(4)))
+    if (all(len_dim /= 0)) call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_dble_4d
+
+  !************************************
+
+  subroutine nf95_gw_var_int_1d(ncid, varid, values)
+
+    ! Integer type, the array has rank 1.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    integer, allocatable, intent(out):: values(:)
+
+    ! Variables local to the procedure:
+    integer nclen
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 1) then
+       print *, "nf95_gw_var_int_1d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 1"
+       stop 1
+    end if
+
+    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen)
+
+    allocate(values(nclen))
+    if (nclen /= 0) call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_int_1d
+
+  !************************************
+
+  subroutine nf95_gw_var_int_2d(ncid, varid, values)
+
+    ! Integer type, the array has rank 2.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    integer, allocatable, intent(out):: values(:, :)
+
+    ! Variables local to the procedure:
+    integer nclen1, nclen2
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 2) then
+       print *, "nf95_gw_var_int_2d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 2"
+       stop 1
+    end if
+
+    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
+    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
+
+    allocate(values(nclen1, nclen2))
+    if (nclen1 /= 0 .and. nclen2 /= 0) call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_int_2d
+
+  !************************************
+
+  subroutine nf95_gw_var_int_3d(ncid, varid, values)
+
+    ! Integer type, the array has rank 3.
+
+    integer, intent(in):: ncid
+    integer, intent(in):: varid
+    integer, allocatable, intent(out):: values(:, :, :)
+
+    ! Variables local to the procedure:
+    integer nclen1, nclen2, nclen3
+    integer, allocatable:: dimids(:)
+
+    !---------------------
+
+    call nf95_inquire_variable(ncid, varid, dimids=dimids)
+
+    if (size(dimids) /= 3) then
+       print *, "nf95_gw_var_int_3d:"
+       print *, "varid = ", varid
+       print *, "rank of NetCDF variable is ", size(dimids), ", not 3"
+       stop 1
+    end if
+
+    call nf95_inquire_dimension(ncid, dimids(1), nclen=nclen1)
+    call nf95_inquire_dimension(ncid, dimids(2), nclen=nclen2)
+    call nf95_inquire_dimension(ncid, dimids(3), nclen=nclen3)
+
+    allocate(values(nclen1, nclen2, nclen3))
+    if (nclen1 /= 0 .and. nclen2 /= 0 .and. nclen3 /= 0) &
+         call NF95_GET_VAR(ncid, varid, values)
+
+  end subroutine nf95_gw_var_int_3d
+
+end module nf95_gw_var_m
diff -uNrp NetCDF95/src/nf95_inq_dimid.f90 NetCDF95-mods/src/nf95_inq_dimid.f90
--- NetCDF95/src/nf95_inq_dimid.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_inq_dimid.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,31 @@
+module nf95_inq_dimid_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_inq_dimid(ncid, name, dimid, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_inq_dimid
+
+    integer,             intent(in) :: ncid
+    character (len = *), intent(in) :: name
+    integer,             intent(out) :: dimid
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_inq_dimid(ncid, name, dimid)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_inq_dimid " // name, ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_inq_dimid
+
+end module nf95_inq_dimid_m
diff -uNrp NetCDF95/src/nf95_inq_varid.f90 NetCDF95-mods/src/nf95_inq_varid.f90
--- NetCDF95/src/nf95_inq_varid.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_inq_varid.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,31 @@
+module nf95_inq_varid_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_inq_varid(ncid, name, varid, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_inq_varid
+
+    integer,             intent(in) :: ncid
+    character(len=*), intent(in):: name
+    integer,             intent(out) :: varid
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_inq_varid(ncid, name, varid)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_inq_varid, name = " // name, ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_inq_varid
+
+end module nf95_inq_varid_m
diff -uNrp NetCDF95/src/nf95_inquire.f90 NetCDF95-mods/src/nf95_inquire.f90
--- NetCDF95/src/nf95_inquire.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_inquire.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,34 @@
+module nf95_inquire_m
+
+  implicit none
+
+contains
+
+
+  subroutine nf95_inquire(ncid, nDimensions, nVariables, nAttributes, &
+       unlimitedDimId, formatNum, ncerr)
+    
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_inquire
+
+    integer,           intent( in) :: ncid
+    integer, optional, intent(out) :: nDimensions, nVariables, nAttributes
+    integer, optional, intent(out) :: unlimitedDimId, formatNum
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_inquire(ncid, nDimensions, nVariables, nAttributes, &
+         unlimitedDimId, formatNum)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_inquire", ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_inquire
+
+end module nf95_inquire_m
diff -uNrp NetCDF95/src/nf95_inquire_attribute.f90 NetCDF95-mods/src/nf95_inquire_attribute.f90
--- NetCDF95/src/nf95_inquire_attribute.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_inquire_attribute.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,35 @@
+module nf95_inquire_attribute_m
+
+  implicit none
+
+contains
+
+
+  subroutine nf95_inquire_attribute(ncid, varid, name, xtype, nclen, attnum, &
+       ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_inquire_attribute
+
+    integer,             intent( in)           :: ncid, varid
+    character (len = *), intent( in)           :: name
+    integer,             intent(out), optional :: xtype, nclen, attnum
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_inquire_attribute(ncid, varid, name, xtype, nclen, &
+         attnum)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_inquire_attribute " // name, ncerr_not_opt, &
+            ncid, varid)
+    end if
+
+  end subroutine nf95_inquire_attribute
+
+end module nf95_inquire_attribute_m
diff -uNrp NetCDF95/src/nf95_inquire_dimension.f90 NetCDF95-mods/src/nf95_inquire_dimension.f90
--- NetCDF95/src/nf95_inquire_dimension.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_inquire_dimension.f90	2020-12-12 23:33:03.262711999 -0600
@@ -0,0 +1,31 @@
+module nf95_inquire_dimension_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_inquire_dimension(ncid, dimid, name, nclen, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_inquire_dimension
+
+    integer,                       intent( in) :: ncid, dimid
+    character (len = *), optional, intent(out) :: name
+    integer,             optional, intent(out) :: nclen
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_inquire_dimension(ncid, dimid, name, nclen)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_inquire_dimension", ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_inquire_dimension
+
+end module nf95_inquire_dimension_m
diff -uNrp NetCDF95/src/nf95_inquire_variable.f90 NetCDF95-mods/src/nf95_inquire_variable.f90
--- NetCDF95/src/nf95_inquire_variable.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_inquire_variable.f90	2020-12-12 23:33:03.263711994 -0600
@@ -0,0 +1,52 @@
+module nf95_inquire_variable_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_inquire_variable(ncid, varid, name, xtype, ndims, dimids, &
+       nAtts, ncerr)
+
+    ! In "nf90_inquire_variable", "dimids" is an assumed-size array.
+    ! This is not optimal.
+    ! We are in the classical case of an array the size of which is
+    ! unknown in the calling procedure, before the call.
+    ! Here we use a better solution: an allocatable argument array.
+    ! This procedure allocates and defines "dimids" if it is present.
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_inquire_variable, nf90_max_var_dims
+
+    integer, intent(in):: ncid, varid
+    character(len = *), optional, intent(out):: name
+    integer, optional, intent(out) :: xtype, ndims
+    integer, optional, allocatable, intent(out) :: dimids(:)
+    integer, optional, intent(out) :: nAtts
+    integer, intent(out), optional :: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+    integer dimids_local(nf90_max_var_dims)
+    integer ndims_not_opt
+
+    !-------------------
+
+    if (present(dimids)) then
+       ncerr_not_opt = nf90_inquire_variable(ncid, varid, name, xtype, &
+            ndims_not_opt, dimids_local, nAtts)
+       dimids = dimids_local(:ndims_not_opt) ! also works if ndims_not_opt == 0
+       if (present(ndims)) ndims = ndims_not_opt
+    else
+       ncerr_not_opt = nf90_inquire_variable(ncid, varid, name, xtype, ndims, &
+            nAtts=nAtts)
+    end if
+
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_inquire_variable", ncerr_not_opt, ncid, varid)
+    end if
+
+  end subroutine nf95_inquire_variable
+
+end module nf95_inquire_variable_m
diff -uNrp NetCDF95/src/nf95_open.f90 NetCDF95-mods/src/nf95_open.f90
--- NetCDF95/src/nf95_open.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_open.f90	2020-12-12 23:33:03.263711994 -0600
@@ -0,0 +1,32 @@
+module nf95_open_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_open(path, mode, ncid, chunksize, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_open
+
+    character(len=*), intent(in):: path
+    integer, intent(in):: mode
+    integer, intent(out):: ncid
+    integer, intent(inout), optional:: chunksize
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_open(path, mode, ncid, chunksize)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_open " // path, ncerr_not_opt)
+    end if
+
+  end subroutine nf95_open
+
+end module nf95_open_m
diff -uNrp NetCDF95/src/nf95_put_att.f90 NetCDF95-mods/src/nf95_put_att.f90
--- NetCDF95/src/nf95_put_att.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_put_att.f90	2020-12-12 23:33:03.263711994 -0600
@@ -0,0 +1,96 @@
+module nf95_put_att_m
+
+  implicit none
+
+  interface nf95_put_att
+     module procedure nf95_put_att_text, nf95_put_att_one_FourByteInt, &
+          nf95_put_att_one_FourByteReal
+  end interface
+
+  private
+  public nf95_put_att
+
+contains
+
+  subroutine nf95_put_att_text(ncid, varid, name, values, ncerr)
+
+    use netcdf, only: nf90_put_att
+    use handle_err_m, only: handle_err
+
+    integer, intent(in) :: ncid, varid
+    character(len = *), intent(in) :: name
+    character(len = *), intent(in) :: values
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_put_att(ncid, varid, name, values)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_att_text " // trim(name), ncerr_not_opt, &
+            ncid, varid)
+    end if
+
+  end subroutine nf95_put_att_text
+
+  !************************************
+
+  subroutine nf95_put_att_one_FourByteInt(ncid, varid, name, values, ncerr)
+
+    use netcdf, only: nf90_put_att
+    use handle_err_m, only: handle_err
+    use typesizes, only: FourByteInt
+
+    integer, intent(in) :: ncid, varid
+    character(len = *), intent(in) :: name
+    integer(kind = FourByteInt), intent(in) :: values
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_put_att(ncid, varid, name, values)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_att_one_FourByteInt " // trim(name), &
+            ncerr_not_opt, ncid, varid)
+    end if
+
+  end subroutine nf95_put_att_one_FourByteInt
+
+  !************************************
+
+  subroutine nf95_put_att_one_FourByteReal(ncid, varid, name, values, ncerr)
+
+    use netcdf, only: nf90_put_att
+    use handle_err_m, only: handle_err
+    use typesizes, only: FourByteReal
+
+    integer, intent(in) :: ncid, varid
+    character(len = *), intent(in) :: name
+    real(kind = FourByteReal), intent(in) :: values
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_put_att(ncid, varid, name, values)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_att_one_FourByteReal " // trim(name), &
+            ncerr_not_opt, ncid, varid)
+    end if
+
+  end subroutine nf95_put_att_one_FourByteReal
+
+end module nf95_put_att_m
diff -uNrp NetCDF95/src/nf95_put_var.f90 NetCDF95-mods/src/nf95_put_var.f90
--- NetCDF95/src/nf95_put_var.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_put_var.f90	2020-12-12 23:33:03.263711994 -0600
@@ -0,0 +1,389 @@
+module nf95_put_var_m
+
+  use netcdf, only: nf90_put_var
+  use handle_err_m, only: handle_err
+  use check_start_count_m, only: check_start_count
+
+  implicit none
+
+  interface nf95_put_var
+     module procedure nf95_put_var_FourByteReal, nf95_put_var_FourByteInt, &
+          nf95_put_var_1D_FourByteReal, nf95_put_var_1D_FourByteInt, &
+          nf95_put_var_1D_EightByteReal, nf95_put_var_2D_FourByteReal, &
+          nf95_put_var_2D_FourByteInt, nf95_put_var_2D_EightByteReal, &
+          nf95_put_var_3D_FourByteReal, nf95_put_var_3D_EightByteReal, &
+          nf95_put_var_4D_FourByteReal, nf95_put_var_4D_EightByteReal
+  end interface
+
+  private
+  public nf95_put_var
+
+contains
+
+  subroutine nf95_put_var_FourByteReal(ncid, varid, values, start, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer, intent(in) :: ncid, varid
+    real(kind = FourByteReal), intent(in) :: values
+    integer, dimension(:), optional, intent(in) :: start
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_FourByteReal", ncid, varid, start, &
+         rank_values=0)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_FourByteReal", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_FourByteReal
+
+  !***********************
+
+  subroutine nf95_put_var_FourByteInt(ncid, varid, values, start, ncerr)
+
+    use typesizes, only: FourByteInt
+
+    integer, intent(in) :: ncid, varid
+    integer(kind = FourByteInt), intent(in) :: values
+    integer, dimension(:), optional, intent(in) :: start
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_FourByteInt", ncid, varid, start, &
+         rank_values=0)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_FourByteInt", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_FourByteInt
+
+  !***********************
+
+  subroutine nf95_put_var_1D_FourByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer,                         intent(in) :: ncid, varid
+    real(kind = FourByteReal), intent(in) :: values(:)
+    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_1D_FourByteReal", ncid, varid, &
+         start, count_nc, rank_values=1)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
+         stride, map)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_1D_FourByteReal", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_1D_FourByteReal
+
+  !***********************
+
+  subroutine nf95_put_var_1D_FourByteInt(ncid, varid, values, start, &
+       count_nc, stride, map, ncerr)
+
+    use typesizes, only: FourByteInt
+
+    integer,                         intent(in) :: ncid, varid
+    integer(kind = FourByteInt), intent(in) :: values(:)
+    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_1D_FourByteInt", ncid, varid, start, &
+         count_nc, rank_values=1)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
+         stride, map)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_1D_FourByteInt", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_1D_FourByteInt
+
+  !***********************
+
+  subroutine nf95_put_var_1D_EightByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, ncerr)
+
+    use typesizes, only: eightByteReal
+
+    integer,                         intent(in) :: ncid, varid
+    real (kind = EightByteReal),     intent(in) :: values(:)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_1D_EightByteReal", ncid, varid, &
+         start, count_nc, rank_values=1)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
+         stride, map)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_1D_eightByteReal", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_1D_EightByteReal
+
+  !***********************
+
+  subroutine nf95_put_var_2D_FourByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer,                         intent(in) :: ncid, varid
+    real (kind = FourByteReal), intent(in) :: values(:, :)
+    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_2D_FourByteReal", ncid, varid, &
+         start, count_nc, rank_values=2)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
+         stride, map)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_2D_FourByteReal", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_2D_FourByteReal
+
+  !***********************
+
+  subroutine nf95_put_var_2D_FourByteint(ncid, varid, values, start, &
+       count_nc, stride, map, ncerr)
+
+    use typesizes, only: FourByteInt
+
+    integer,                         intent(in) :: ncid, varid
+    integer(kind = FourByteInt), intent(in) :: values(:, :)
+    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_2D_FourByteInt", ncid, varid, &
+         start, count_nc, rank_values=2)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
+         stride, map)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_2D_FourByteInt", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_2D_FourByteint
+
+  !***********************
+
+  subroutine nf95_put_var_2D_EightByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, ncerr)
+
+    use typesizes, only: EightByteReal
+
+    integer,                         intent(in) :: ncid, varid
+    real (kind = EightByteReal), intent(in) :: values(:, :)
+    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_2D_EightByteReal", ncid, varid, &
+         start, count_nc, rank_values=2)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
+         stride, map)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_2D_EightByteReal", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_2D_EightByteReal
+
+  !***********************
+
+  subroutine nf95_put_var_3D_FourByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer,                         intent(in) :: ncid, varid
+    real (kind = FourByteReal), intent(in) :: values(:, :, :)
+    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_3D_FourByteReal", ncid, varid, &
+         start, count_nc, rank_values=3)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
+         stride, map)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_3D_FourByteReal", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_3D_FourByteReal
+
+  !***********************
+
+  subroutine nf95_put_var_3D_EightByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, ncerr)
+
+    use typesizes, only: eightByteReal
+
+    integer,                         intent(in) :: ncid, varid
+    real (kind = EightByteReal),     intent(in) :: values(:, :, :)
+    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_3D_EightByteReal", ncid, varid, &
+         start, count_nc, rank_values=3)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
+         stride, map)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_3D_eightByteReal", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_3D_EightByteReal
+
+  !***********************
+
+  subroutine nf95_put_var_4D_FourByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, ncerr)
+
+    use typesizes, only: FourByteReal
+
+    integer,                         intent(in) :: ncid, varid
+    real (kind = FourByteReal), intent(in) :: values(:, :, :, :)
+    integer, dimension(:), optional, intent(in) :: start, count_nc, stride, map
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_4D_FourByteReal", ncid, varid, &
+         start, count_nc, rank_values=4)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
+         stride, map)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_4D_FourByteReal", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_4D_FourByteReal
+
+  !***********************
+
+  subroutine nf95_put_var_4D_EightByteReal(ncid, varid, values, start, &
+       count_nc, stride, map, ncerr)
+
+    use typesizes, only: EightByteReal
+
+    integer, intent(in):: ncid, varid
+    real(kind = EightByteReal), intent(in):: values(:, :, :, :)
+    integer, dimension(:), optional, intent(in):: start, count_nc, stride, map
+    integer, intent(out), optional:: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    call check_start_count("nf95_put_var_4D_EightByteReal", ncid, varid, &
+         start, count_nc, rank_values=4)
+
+    ncerr_not_opt = nf90_put_var(ncid, varid, values, start, count_nc, &
+         stride, map)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_put_var_4D_EightByteReal", ncerr_not_opt, ncid, &
+            varid)
+    end if
+
+  end subroutine nf95_put_var_4D_EightByteReal
+
+end module nf95_put_var_m
diff -uNrp NetCDF95/src/nf95_redef.f90 NetCDF95-mods/src/nf95_redef.f90
--- NetCDF95/src/nf95_redef.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_redef.f90	2020-12-12 23:33:03.263711994 -0600
@@ -0,0 +1,29 @@
+module nf95_redef_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_redef(ncid, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_redef
+
+    integer, intent( in) :: ncid
+    integer, intent(out), optional :: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_redef(ncid)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_redef", ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_redef
+
+end module nf95_redef_m
diff -uNrp NetCDF95/src/nf95_sync.f90 NetCDF95-mods/src/nf95_sync.f90
--- NetCDF95/src/nf95_sync.f90	1969-12-31 18:00:00.000000000 -0600
+++ NetCDF95-mods/src/nf95_sync.f90	2020-12-12 23:33:03.263711994 -0600
@@ -0,0 +1,29 @@
+module nf95_sync_m
+
+  implicit none
+
+contains
+
+  subroutine nf95_sync(ncid, ncerr)
+
+    use handle_err_m, only: handle_err
+    use netcdf, only: nf90_sync
+
+    integer, intent( in) :: ncid
+    integer, intent(out), optional :: ncerr
+
+    ! Variable local to the procedure:
+    integer ncerr_not_opt
+
+    !-------------------
+
+    ncerr_not_opt = nf90_sync(ncid)
+    if (present(ncerr)) then
+       ncerr = ncerr_not_opt
+    else
+       call handle_err("nf95_sync", ncerr_not_opt, ncid)
+    end if
+
+  end subroutine nf95_sync
+
+end module nf95_sync_m
